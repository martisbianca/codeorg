/*! For license information please see nr-full-1.268.0.min.js.LICENSE.txt */
"use strict";
(self["webpackChunk:NRBA-1.268.0.PROD"] = self["webpackChunk:NRBA-1.268.0.PROD"] || []).push([
    [891], {
        7699: (e, t, i) => {
            i.d(t, {
                I: () => r,
                N: () => s
            });
            const s = 64e3,
                r = 1e6
        },
        2123: (e, t, i) => {
            function s(e) {
                return !!e && e.self !== e.top
            }
            i.d(t, {
                v: () => s
            })
        },
        1140: (e, t, i) => {
            i.d(t, {
                n: () => u
            });
            var s = i(9422),
                r = i(4777),
                n = i(4624),
                a = i(3878),
                o = i(6154),
                c = i(2843);
            if (o.bv) {
                o.gm.cleanupTasks = [];
                const e = o.gm.close;
                o.gm.close = () => {
                    for (let e of o.gm.cleanupTasks) e();
                    e()
                }
            }
            var h = i(2614);
            class u extends r.J {
                constructor(e, t, i) {
                    var s;
                    super(i), this.endpoint = e, this.opts = t || {}, this.started = !1, this.timeoutHandle = null, this.aborted = !1, this.harvesting = !1, this.harvest = new n.M(this.sharedContext), s = this.unload.bind(this), o.RI ? ((0, c.u)(s, !0), (0, a.sp)("pagehide", s)) : o.bv && o.gm.cleanupTasks.push(s), this.sharedContext ? .ee.on(h.tS.RESET, (() => this.runHarvest({
                        forceNoRetry: !0
                    })))
                }
                unload() {
                    this.aborted || (this.opts.onUnload && this.opts.onUnload(), this.runHarvest({
                        unload: !0
                    }))
                }
                startTimer(e, t) {
                    this.interval = e, this.started = !0, this.scheduleHarvest(null != t ? t : this.interval)
                }
                stopTimer(e = !1) {
                    this.aborted = e, this.started = !1, this.timeoutHandle && clearTimeout(this.timeoutHandle)
                }
                scheduleHarvest(e, t) {
                    this.timeoutHandle || (null == e && (e = this.interval), this.timeoutHandle = setTimeout((() => {
                        this.timeoutHandle = null, this.runHarvest(t)
                    }), 1e3 * e))
                }
                runHarvest(e) {
                    if (this.aborted) return;
                    this.harvesting = !0;
                    const t = t => {
                        this.harvesting = !1, e ? .forceNoRetry && (t.retry = !1), this.onHarvestFinished(e, t)
                    };
                    let i, r, n = [];
                    if (this.opts.getPayload) {
                        if (i = s.mj({
                                isFinalHarvest: e ? .unload
                            }), !i) return !1;
                        const t = !e ? .unload && i === s.nF;
                        if (r = this.opts.getPayload({
                                retry: t,
                                ...e
                            }), !r) return void(this.started && this.scheduleHarvest());
                        r = "[object Array]" === Object.prototype.toString.call(r) ? r : [r], n.push(...r)
                    }
                    let a = e => this.harvest.sendX(e);
                    n.length ? a = this.opts.raw ? e => this.harvest._send(e) : e => this.harvest.send(e) : n.push(void 0), n.forEach((s => {
                        a({
                            endpoint: this.endpoint,
                            payload: s,
                            opts: e,
                            submitMethod: i,
                            cbFinished: t,
                            customUrl: this.opts.customUrl,
                            raw: this.opts.raw
                        })
                    })), this.started && this.scheduleHarvest()
                }
                onHarvestFinished(e, t) {
                    if (this.opts.onFinished && this.opts.onFinished(t), t.sent && t.retry) {
                        const i = t.delay || this.opts.retryDelay;
                        this.started && i ? (clearTimeout(this.timeoutHandle), this.timeoutHandle = null, this.scheduleHarvest(i, e)) : !this.started && i && this.scheduleHarvest(i, e)
                    }
                }
            }
        },
        4624: (e, t, i) => {
            i.d(t, {
                M: () => v
            });
            var s = i(3762),
                r = i(3304),
                n = i(9422);
            var a = i(2555),
                o = i(9417),
                c = i(3371),
                h = i(9119),
                u = i(3878),
                d = i(4777),
                l = i(9324),
                p = i(6154),
                f = i(944),
                m = i(1863);
            const g = {};
            class v extends d.J {
                constructor(e) {
                    super(e), this.tooManyRequestsDelay = (0, o.gD)(this.sharedContext.agentIdentifier, "harvest.tooManyRequestsDelay") || 60, this.obfuscator = (0, c.f)(this.sharedContext.agentIdentifier).obfuscator, this._events = {}
                }
                sendX(e = {}) {
                    const t = n.mj({
                            isFinalHarvest: e.opts ? .unload
                        }),
                        i = {
                            retry: !e.opts ? .unload && t === n.nF,
                            isFinalHarvest: !0 === e.opts ? .unload
                        },
                        s = this.createPayload(e.endpoint, i);
                    return this._send.bind(this)({ ...e,
                        payload: s,
                        submitMethod: t
                    })
                }
                send(e = {}) {
                    return this._send.bind(this)(e)
                }
                _send({
                    endpoint: e,
                    payload: t = {},
                    opts: i = {},
                    submitMethod: h,
                    cbFinished: d,
                    customUrl: l,
                    raw: m,
                    includeBaseParams: v = !0
                }) {
                    const y = (0, a.Vp)(this.sharedContext.agentIdentifier);
                    if (!y.errorBeacon) return !1;
                    const b = (0, c.f)(this.sharedContext.agentIdentifier);
                    let {
                        body: T,
                        qs: S
                    } = this.cleanPayload(t);
                    if (0 === Object.keys(T).length && !i ? .sendEmptyBody) return d && d({
                        sent: !1
                    }), !1;
                    const w = (0, o.D0)(this.sharedContext.agentIdentifier),
                        E = !1 === w.ssl ? "http" : "https",
                        I = w.proxy.beacon || y.errorBeacon,
                        R = "rum" !== e ? "/".concat(e) : "";
                    let A = "".concat(E, "://").concat(I).concat(R, "/1/").concat(y.licenseKey);
                    l && (A = l), m && (A = "".concat(E, "://").concat(I, "/").concat(e));
                    const x = !m && v ? this.baseQueryString(S, e) : "";
                    let M = (0, s.WL)(S, b.maxBytes);
                    h || (h = n.mj({
                        isFinalHarvest: i.unload
                    })), "" === x && M.startsWith("&") && (M = M.substring(1));
                    const N = "".concat(A, "?").concat(x).concat(M);
                    !!S ? .attributes ? .includes("gzip") || (T = "events" === e ? T.e : (0, r.A)(T), T.length > 75e4 && 1 === (g[e] = (g ? .[e] || 0) + 1) && (0, f.R)(28, e)), T && 0 !== T.length && "{}" !== T && "[]" !== T || (T = "");
                    const k = [];
                    k.push({
                        key: "content-type",
                        value: "text/plain"
                    });
                    let F = h({
                        url: N,
                        body: T,
                        sync: i.unload && p.bv,
                        headers: k
                    });
                    if (!i.unload && d && h === n.nF) {
                        const e = this;
                        F.addEventListener("loadend", (function() {
                            const t = {
                                sent: 0 !== this.status,
                                status: this.status,
                                xhr: this,
                                fullUrl: N
                            };
                            429 === this.status ? (t.retry = !0, t.delay = e.tooManyRequestsDelay) : 408 !== this.status && 500 !== this.status && 503 !== this.status || (t.retry = !0), i.needResponse && (t.responseText = this.responseText), d(t)
                        }), (0, u.jT)(!1))
                    }
                    return F
                }
                baseQueryString(e, t) {
                    const i = (0, c.f)(this.sharedContext.agentIdentifier),
                        r = (0, a.Vp)(this.sharedContext.agentIdentifier),
                        n = this.obfuscator.obfuscateString((0, h.L)("" + location)),
                        o = 1 === i ? .session ? .state.sessionReplayMode && "jserrors" !== t,
                        u = ["a=" + r.applicationID, (0, s.uR)("sa", r.sa ? "" + r.sa : ""), (0, s.uR)("v", l.xv), y(r), (0, s.uR)("ct", i.customTransaction), "&rst=" + (0, m.t)(), "&ck=0", "&s=" + (i.session ? .state.value || "0"), (0, s.uR)("ref", n), (0, s.uR)("ptid", i.ptid ? "" + i.ptid : "")];
                    return o && u.push((0, s.uR)("hr", "1", e)), u.join("")
                }
                createPayload(e, t) {
                    const i = this._events[e],
                        s = {
                            body: {},
                            qs: {}
                        };
                    if (Array.isArray(i) && i.length > 0)
                        for (let e = 0; e < i.length; e++) {
                            const r = i[e](t);
                            r && (s.body = { ...s.body,
                                ...r.body || {}
                            }, s.qs = { ...s.qs,
                                ...r.qs || {}
                            })
                        }
                    return s
                }
                cleanPayload(e = {}) {
                    const t = e => "undefined" != typeof Uint8Array && e instanceof Uint8Array || Array.isArray(e) ? e : "string" == typeof e ? e.length > 0 ? e : null : Object.entries(e || {}).reduce(((e, [t, i]) => (("number" == typeof i || "string" == typeof i && i.length > 0 || "object" == typeof i && Object.keys(i || {}).length > 0) && (e[t] = i), e)), {});
                    return {
                        body: t(e.body),
                        qs: t(e.qs)
                    }
                }
                on(e, t) {
                    Array.isArray(this._events[e]) || (this._events[e] = []), this._events[e].push(t)
                }
            }

            function y(e) {
                return e.transactionName ? (0, s.uR)("to", e.transactionName) : (0, s.uR)("t", e.tNamePlain || "Unnamed Transaction")
            }
        },
        5519: (e, t, i) => {
            i.d(t, {
                AQ: () => u,
                me: () => o,
                sH: () => c,
                uJ: () => h
            });
            var s = i(3304),
                r = i(3371),
                n = Object.prototype.hasOwnProperty,
                a = 64;

            function o(e, t, i) {
                return e || 0 === e || "" === e ? t(e) + (i ? "," : "") : "!"
            }

            function c(e, t) {
                return t ? Math.floor(e).toString(36) : void 0 === e || 0 === e ? "" : Math.floor(e).toString(36)
            }

            function h(e) {
                let t = 0;
                const i = Object.prototype.hasOwnProperty.call(Object, "create") ? Object.create(null) : {},
                    s = (0, r.f)(e).obfuscator;
                return function(e) {
                    if (void 0 === e || "" === e) return "";
                    return e = s.obfuscateString(String(e)), n.call(i, e) ? c(i[e], !0) : (i[e] = t++, function(e) {
                        return "'" + e.replace(d, "\\$1")
                    }(e))
                }
            }

            function u(e, t) {
                var i = [];
                return Object.entries(e || {}).forEach((([e, r]) => {
                    if (!(i.length >= a)) {
                        var n, o = 5;
                        switch (e = t(e), typeof r) {
                            case "object":
                                r ? n = t((0, s.A)(r)) : o = 9;
                                break;
                            case "number":
                                o = 6, n = r % 1 ? r : r + ".";
                                break;
                            case "boolean":
                                o = r ? 7 : 8;
                                break;
                            case "undefined":
                                o = 9;
                                break;
                            default:
                                n = t(r)
                        }
                        i.push([o, e + (n ? "," + n : "")])
                    }
                })), i
            }
            var d = /([,\\;])/g
        },
        2733: (e, t, i) => {
            i.d(t, {
                eM: () => f,
                si: () => m,
                ss: () => p
            });
            var s = "Start",
                r = "End",
                n = "unloadEvent",
                a = "redirect",
                o = "domainLookup",
                c = "onnect",
                h = "request",
                u = "response",
                d = "loadEvent",
                l = "domContentLoadedEvent";
            const p = [];

            function f(e, t, i = {}, p = !1) {
                if (t) return i.of = e, g(i.of, i, "n", !0), g(t[n + s], i, "u", p), g(t[a + s], i, "r", p), g(t[n + r], i, "ue", p), g(t[a + r], i, "re", p), g(t["fetch" + s], i, "f", p), g(t[o + s], i, "dn", p), g(t[o + r], i, "dne", p), g(t["c" + c + s], i, "c", p), g(t["secureC" + c + "ion" + s], i, "s", p), g(t["c" + c + r], i, "ce", p), g(t[h + s], i, "rq", p), g(t[u + s], i, "rp", p), g(t[u + r], i, "rpe", p), g(t.domLoading, i, "dl", p), g(t.domInteractive, i, "di", p), g(t[l + s], i, "ds", p), g(t[l + r], i, "de", p), g(t.domComplete, i, "dc", p), g(t[d + s], i, "l", p), g(t[d + r], i, "le", p), i
            }

            function m(e, t) {
                var i;
                return g("number" == typeof(i = e.type) ? i : {
                    navigate: void 0,
                    reload: 1,
                    back_forward: 2,
                    prerender: 3
                }[i], t, "ty"), g(e.redirectCount, t, "rc"), t
            }

            function g(e, t, i, s) {
                if ("number" == typeof e && e > 0) {
                    if (s) {
                        const i = t ? .of > 0 ? t.of : 0;
                        e = Math.max(e - i, 0)
                    }
                    e = Math.round(e), t[i] = e, p.push(e)
                } else p.push(void 0)
            }
        },
        9119: (e, t, i) => {
            i.d(t, {
                L: () => n
            });
            var s = /([^?#]*)[^#]*(#[^?]*|$).*/,
                r = /([^?#]*)().*/;

            function n(e, t) {
                return e.replace(t ? s : r, "$1$2")
            }
        },
        3762: (e, t, i) => {
            i.d(t, {
                WL: () => h,
                uR: () => u
            });
            var s = i(3304),
                r = {
                    "%2C": ",",
                    "%3A": ":",
                    "%2F": "/",
                    "%40": "@",
                    "%24": "$",
                    "%3B": ";"
                },
                n = Object.keys(r),
                a = new RegExp(n.join("|"), "g");

            function o(e) {
                return r[e]
            }

            function c(e) {
                return null == e ? "null" : encodeURIComponent(e).replace(a, o)
            }

            function h(e, t) {
                var i = 0,
                    r = "";
                return Object.entries(e || {}).forEach((([e, n]) => {
                    var a, o, h = [];
                    if ("string" == typeof n || !Array.isArray(n) && null != n && n.toString().length) a = "&" + e + "=" + c(n), i += a.length, r += a;
                    else if (Array.isArray(n) && n.length) {
                        for (i += 9, o = 0; o < n.length && (a = c((0, s.A)(n[o])), i += a.length, !(void 0 !== t && i >= t)); o++) h.push(a);
                        r += "&" + e + "=%5B" + h.join(",") + "%5D"
                    }
                })), r
            }

            function u(e, t, i = {}) {
                return Object.keys(i).includes(e) ? "" : t && "string" == typeof t ? "&" + e + "=" + c(t) : ""
            }
        },
        4284: (e, t, i) => {
            i.d(t, {
                p: () => r
            });
            var s = i(6154);

            function r() {
                return Boolean("file:" === s.gm ? .location ? .protocol)
            }
        },
        9422: (e, t, i) => {
            i.d(t, {
                mj: () => r,
                nF: () => n
            });
            var s = i(6154);

            function r({
                isFinalHarvest: e = !1
            } = {}) {
                return e && s.RI && s.Vr ? a : n
            }

            function n({
                url: e,
                body: t = null,
                sync: i,
                method: s = "POST",
                headers: r = [{
                    key: "content-type",
                    value: "text/plain"
                }]
            }) {
                const n = new XMLHttpRequest;
                n.open(s, e, !i);
                try {
                    "withCredentials" in n && (n.withCredentials = !0)
                } catch (e) {}
                return r.forEach((e => {
                    n.setRequestHeader(e.key, e.value)
                })), n.send(t), n
            }

            function a({
                url: e,
                body: t
            }) {
                try {
                    return window.navigator.sendBeacon.bind(window.navigator)(e, t)
                } catch (e) {
                    return !1
                }
            }
        },
        3311: (e, t, i) => {
            function s(e, t, i = "string", r = []) {
                return e && "object" == typeof e ? (Object.keys(e).forEach((n => {
                    "object" == typeof e[n] ? s(e[n], t, i, r) : typeof e[n] !== i || r.includes(n) || (e[n] = t(e[n]))
                })), e) : e
            }
            i.d(t, {
                G: () => s
            })
        },
        1083: (e, t, i) => {
            i.d(t, {
                w: () => s
            });
            const s = {
                FIRST_PAINT: "fp",
                FIRST_CONTENTFUL_PAINT: "fcp",
                FIRST_INPUT_DELAY: "fi",
                LARGEST_CONTENTFUL_PAINT: "lcp",
                CUMULATIVE_LAYOUT_SHIFT: "cls",
                INTERACTION_TO_NEXT_PAINT: "inp",
                TIME_TO_FIRST_BYTE: "ttfb"
            }
        },
        5344: (e, t, i) => {
            i.d(t, {
                j: () => a
            });
            var s = i(7226),
                r = i(6154),
                n = i(1083);
            const a = new(i(6773).x)(n.w.FIRST_CONTENTFUL_PAINT);
            if (r.RI)
                if (r.sb) try {
                    if (!r.mw) {
                        performance.getEntriesByType("paint").forEach((e => {
                            "first-contentful-paint" === e.name && a.update({
                                value: Math.floor(e.startTime)
                            })
                        }))
                    }
                } catch (e) {} else(0, s.zB)((({
                    value: e,
                    attribution: t
                }) => {
                    if (r.mw || a.isValid) return;
                    const i = {
                        timeToFirstByte: t.timeToFirstByte,
                        firstByteToFCP: t.firstByteToFCP,
                        loadState: t.loadState
                    };
                    a.update({
                        value: e,
                        attrs: i
                    })
                }))
        },
        5181: (e, t, i) => {
            i.d(t, {
                J: () => n
            });
            var s = i(6154),
                r = i(1083);
            const n = new(i(6773).x)(r.w.FIRST_PAINT);
            if (s.RI) {
                const e = e => {
                    e.forEach((e => {
                        "first-paint" !== e.name || n.isValid || (t.disconnect(), n.update({
                            value: e.startTime
                        }))
                    }))
                };
                let t;
                try {
                    PerformanceObserver.supportedEntryTypes.includes("paint") && !s.mw && (t = new PerformanceObserver((t => {
                        Promise.resolve().then((() => {
                            e(t.getEntries())
                        }))
                    })), t.observe({
                        type: "paint",
                        buffered: !0
                    }))
                } catch (e) {}
            }
        },
        8779: (e, t, i) => {
            i.d(t, {
                j: () => o
            });
            var s = i(6154),
                r = i(1083),
                n = i(6773),
                a = i(7226);
            const o = new n.x(r.w.TIME_TO_FIRST_BYTE);
            if (s.RI && "undefined" != typeof PerformanceNavigationTiming && !s.OF && window === window.parent)(0, a.Ck)((({
                value: e,
                attribution: t
            }) => {
                o.isValid || o.update({
                    value: e,
                    attrs: {
                        navigationEntry: t.navigationEntry
                    }
                })
            }));
            else if (!o.isValid) {
                const e = {};
                for (let t in s.gm ? .performance ? .timing || {}) e[t] = Math.max(s.gm ? .performance ? .timing[t] - s.WN, 0);
                o.update({
                    value: e.responseStart,
                    attrs: {
                        navigationEntry: e
                    }
                })
            }
        },
        6773: (e, t, i) => {
            i.d(t, {
                x: () => s
            });
            class s {#
                e = new Set;
                history = [];
                constructor(e, t) {
                    this.name = e, this.attrs = {}, this.roundingMethod = "function" == typeof t ? t : Math.floor
                }
                update({
                    value: e,
                    attrs: t = {}
                }) {
                    if (null == e || e < 0) return;
                    const i = {
                        value: this.roundingMethod(e),
                        name: this.name,
                        attrs: t
                    };
                    this.history.push(i), this.#e.forEach((e => {
                        try {
                            e(i)
                        } catch (e) {}
                    }))
                }
                get current() {
                    return this.history[this.history.length - 1] || {
                        value: void 0,
                        name: this.name,
                        attrs: {}
                    }
                }
                get isValid() {
                    return this.current.value >= 0
                }
                subscribe(e, t = !0) {
                    if ("function" == typeof e) return this.#e.add(e), this.isValid && t && this.history.forEach((t => {
                        e(t)
                    })), () => {
                        this.#e.delete(e)
                    }
                }
            }
        },
        6674: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => I
            });
            var s = i(3606),
                r = i(3304),
                n = i(9908),
                a = i(2555),
                o = i(9417),
                c = i(3371),
                h = i(1140),
                u = i(7295),
                d = i(9300),
                l = i(860),
                p = i(3969),
                f = i(5942);

            function m({
                body: e,
                query: t
            } = {}) {
                if (e || t) try {
                    const i = function(e) {
                        if (!e) return;
                        Array.isArray(e) || (e = [e]);
                        const t = [],
                            i = [];
                        for (let s of e) {
                            const e = g(s);
                            e && (t.push(e.operationName), i.push(e.operationType))
                        }
                        if (!i.length) return;
                        return {
                            operationName: t.join(","),
                            operationType: i.join(","),
                            operationFramework: "GraphQL"
                        }
                    }(v(e));
                    if (i) return i;
                    const s = g(function(e) {
                        if (!e || "string" != typeof e) return;
                        const t = new URLSearchParams(e);
                        return v(Object.fromEntries(t))
                    }(t));
                    if (s) return s
                } catch (e) {}
            }

            function g(e) {
                if ("object" != typeof e || !e.query || "string" != typeof e.query) return;
                const t = e.query.trim().match(/^(query|mutation|subscription)\s?(\w*)/),
                    i = t ? .[1];
                if (!i) return;
                return {
                    operationName: e.operationName || t ? .[2] || "Anonymous",
                    operationType: i,
                    operationFramework: "GraphQL"
                }
            }

            function v(e) {
                let t;
                if (!e || "string" != typeof e && "object" != typeof e) return;
                if (t = "string" == typeof e ? JSON.parse(e) : e, i = t, i ? .constructor !== {}.constructor && !Array.isArray(t)) return;
                var i;
                let s = !1;
                return s = Array.isArray(t) ? t.some((e => y(e))) : y(t), s ? t : void 0
            }

            function y(e) {
                return !("object" != typeof e || !e.query || "string" != typeof e.query)
            }
            var b = i(384),
                T = i(5519),
                S = i(7699);
            class w {
                constructor(e, t) {
                    this.addString = (0, T.uJ)(t.agentIdentifier), this.events = e, this.payload = "bel.7;";
                    for (let i = 0; i < e.length; i++) {
                        const s = e[i],
                            r = [(0, T.sH)(s.startTime), (0, T.sH)(s.endTime - s.startTime), (0, T.sH)(0), (0, T.sH)(0), this.addString(s.method), (0, T.sH)(s.status), this.addString(s.domain), this.addString(s.path), (0, T.sH)(s.requestSize), (0, T.sH)(s.responseSize), "fetch" === s.type ? 1 : "", this.addString(0), (0, T.me)(s.spanId, this.addString, !0) + (0, T.me)(s.traceId, this.addString, !0) + (0, T.me)(s.spanTimestamp, T.sH, !1)];
                        let n = "2,";
                        const o = (0, a.Vp)(t.agentIdentifier).jsAttributes,
                            c = (0, T.AQ)({ ...o || {},
                                ...s.gql || {}
                            }, this.addString);
                        r.unshift((0, T.sH)(c.length)), n += r.join(","), c && c.length > 0 && (n += ";" + c.join(";")), i + 1 < e.length && (n += ";"), this.payload += n
                    }
                    this.tooBig = 2 * this.payload.length > S.I
                }
            }
            var E = i(8771);
            class I extends f.r {
                static featureName = d.T;#
                t;#
                i;#
                s;
                constructor(e, t) {
                    super(e, t, d.T), this.#t = (0, a.Vp)(e), this.#i = (0, c.f)(e), this.#s = (0, o.D0)(e);
                    const i = this.#s.ajax.harvestTimeSeconds || 10;
                    (0, u.Xv)(this.#i.denyList), this.ajaxEvents = new E.Z, this.spaAjaxEvents = {};
                    const r = this;
                    this.ee.on("interactionDone", ((e, t) => {
                        this.spaAjaxEvents[e.id] ? .hasData && (t || this.ajaxEvents.merge(this.spaAjaxEvents[e.id]), delete this.spaAjaxEvents[e.id])
                    })), (0, s.i)("returnAjax", (e => this.ajaxEvents.add(e)), this.featureName, this.ee), (0, s.i)("xhr", (function() {
                        r.storeXhr(...arguments, this)
                    }), this.featureName, this.ee), this.waitForFlags([]).then((() => {
                        new h.n("events", {
                            onFinished: this.onEventsHarvestFinished.bind(this),
                            getPayload: this.prepareHarvest.bind(this)
                        }, this).startTimer(i), this.drain()
                    }))
                }
                storeXhr(e, t, i, s, a, o) {
                    let c;
                    t.time = i, c = e.cat ? (0, r.A)([e.status, e.cat]) : (0, r.A)([e.status, e.host, e.pathname]);
                    const h = (0, u.gX)(e),
                        d = this.#s.feature_flags ? .includes("ajax_metrics_deny_list");
                    if (!h && d || this.aggregator.store("xhr", c, e, t), !h) return void(e.hostname === this.#t.errorBeacon || this.#s.proxy ? .beacon && e.hostname === this.#s.proxy.beacon ? ((0, n.p)(p.xV, ["Ajax/Events/Excluded/Agent"], void 0, l.K.metrics, this.ee), d && (0, n.p)(p.xV, ["Ajax/Metrics/Excluded/Agent"], void 0, l.K.metrics, this.ee)) : ((0, n.p)(p.xV, ["Ajax/Events/Excluded/App"], void 0, l.K.metrics, this.ee), d && (0, n.p)(p.xV, ["Ajax/Metrics/Excluded/App"], void 0, l.K.metrics, this.ee)));
                    (0, n.p)("bstXhrAgg", ["xhr", c, e, t], void 0, l.K.sessionTrace, this.ee);
                    const f = {
                        method: e.method,
                        status: e.status,
                        domain: e.host,
                        path: e.pathname,
                        requestSize: t.txSize,
                        responseSize: t.rxSize,
                        type: a,
                        startTime: i,
                        endTime: s,
                        callbackDuration: t.cbTime
                    };
                    o.dt && (f.spanId = o.dt.spanId, f.traceId = o.dt.traceId, f.spanTimestamp = Math.floor(this.#i.timeKeeper.correctAbsoluteTimestamp(o.dt.timestamp))), f.gql = e.gql = m({
                        body: o.body,
                        query: o.parsedOrigin ? .search
                    }), f.gql && (0, n.p)(p.xV, ["Ajax/Events/GraphQL/Bytes-Added", (0, r.A)(f.gql).length], void 0, l.K.metrics, this.ee);
                    if (Boolean((0, b.nY)(this.agentIdentifier) ? .features ? .[l.K.softNav]))(0, n.p)("ajax", [f], void 0, l.K.softNav, this.ee);
                    else if (o.spaNode) {
                        const e = o.spaNode.interaction.id;
                        this.spaAjaxEvents[e] ? ? = new E.Z, this.spaAjaxEvents[e].add(f)
                    } else this.ajaxEvents.add(f)
                }
                prepareHarvest(e) {
                    if (e = e || {}, 0 === this.ajaxEvents.buffer.length) return null;
                    const t = this.#r(this.ajaxEvents.buffer),
                        i = [];
                    for (let e = 0; e < t.length; e++) i.push({
                        body: {
                            e: t[e]
                        }
                    });
                    return e.retry ? this.ajaxEvents.hold() : this.ajaxEvents.clear(), i
                }
                onEventsHarvestFinished(e) {
                    e.retry && this.ajaxEvents.held.hasData ? this.ajaxEvents.unhold() : this.ajaxEvents.held.clear()
                }#
                r(e, t) {
                    t = t || 1;
                    const i = [],
                        s = e.length / t,
                        r = function(e, t) {
                            t = t || e.length;
                            const i = [];
                            for (let s = 0, r = e.length; s < r; s += t) i.push(new w(e.slice(s, s + t), this));
                            return i
                        }.call(this, e, s);
                    let n = !1;
                    for (let e = 0; e < r.length; e++) {
                        const t = r[e];
                        if (t.tooBig) {
                            if (t.events.length > 1) {
                                n = !0;
                                break
                            }
                        } else i.push(t.payload)
                    }
                    return n ? this.#r(e, ++t) : i
                }
            }
        },
        8019: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => E
            });
            var s = i(3304),
                r = i(1140),
                n = i(9119),
                a = i(2555),
                o = i(9417),
                c = i(3371),
                h = i(3333),
                u = i(6154),
                d = i(5942),
                l = i(944),
                p = i(1863),
                f = i(3606),
                m = i(1687),
                g = i(3969),
                v = i(8771),
                y = i(3311),
                b = i(7699);
            class T {
                constructor(e, t) {
                    this.event = e, this.count = 1, this.originMs = Math.floor(e.timeStamp), this.relativeMs = [0], this.selectorPath = t, this.rageClick = void 0
                }
                aggregate(e) {
                    this.count++, this.relativeMs.push(Math.floor(e.timeStamp - this.originMs)), this.isRageClick() && (this.rageClick = !0)
                }
                isRageClick() {
                    const e = this.relativeMs.length;
                    return "click" === this.event.type && e >= h.nf && this.relativeMs[e - 1] - this.relativeMs[e - h.nf] < h.mq
                }
            }
            class S {#
                n = void 0;#
                a = "";
                get aggregationEvent() {
                    const e = this.#n;
                    return this.#a = "", this.#n = void 0, e
                }
                process(e) {
                    if (!e) return;
                    const t = function(e) {
                            let t;
                            t = h.qN.includes(e.type) || e.target === window ? "window" : e.target === document ? "document" : (e => {
                                if (!e) return;
                                let t = "",
                                    i = (e => {
                                        try {
                                            let t = 1;
                                            const {
                                                tagName: i
                                            } = e;
                                            for (; e.previousElementSibling;) e.previousElementSibling.tagName === i && t++, e = e.previousElementSibling;
                                            return t
                                        } catch (e) {}
                                    })(e);
                                try {
                                    for (; e ? .tagName;) {
                                        const {
                                            id: i,
                                            localName: s
                                        } = e;
                                        t = [s, i ? "#".concat(i) : "", t ? ">".concat(t) : ""].join(""), e = e.parentNode
                                    }
                                } catch (e) {}
                                return t ? i ? "".concat(t, ":nth-of-type(").concat(i, ")") : t : void 0
                            })(e.target);
                            return t
                        }(e),
                        i = function(e, t) {
                            let i = e.type;
                            "scrollend" !== e.type && (i += "-" + t);
                            return i
                        }(e, t);
                    if (!i || i !== this.#a) {
                        const s = this.#n;
                        return this.#a = i, this.#n = new T(e, t), s
                    }
                    this.#n.aggregate(e)
                }
            }
            var w = i(2123);
            class E extends d.r {#
                i;
                static featureName = h.TZ;
                constructor(e, t) {
                    super(e, t, h.TZ);
                    const i = (0, o.D0)(this.agentIdentifier);
                    this.eventsPerHarvest = 1e3, this.harvestTimeSeconds = i.generic_events.harvestTimeSeconds, this.referrerUrl = u.RI && document.referrer ? (0, n.L)(document.referrer) : void 0, this.events = new v.Z, this.#i = (0, c.f)(this.agentIdentifier), this.waitForFlags(["ins"]).then((([e]) => {
                        if (!e) return this.blocked = !0, void(0, m.x3)(this.agentIdentifier, this.featureName);
                        const t = [];
                        i.page_action.enabled && (0, f.i)("api-addPageAction", ((e, t, i) => {
                            this.addEvent({ ...i,
                                eventType: "PageAction",
                                timestamp: Math.floor(this.#i.timeKeeper.correctRelativeTimestamp(e)),
                                timeSinceLoad: e / 1e3,
                                actionName: t,
                                referrerUrl: this.referrerUrl,
                                ...u.RI && {
                                    browserWidth: window.document.documentElement ? .clientWidth,
                                    browserHeight: window.document.documentElement ? .clientHeight
                                }
                            })
                        }), this.featureName, this.ee), u.RI && i.user_actions.enabled && (this.userActionAggregator = new S, this.addUserAction = e => {
                            try {
                                if (e ? .event) {
                                    const {
                                        target: t,
                                        timeStamp: i,
                                        type: s
                                    } = e.event;
                                    this.addEvent({
                                        eventType: "UserAction",
                                        timestamp: Math.floor(this.#i.timeKeeper.correctRelativeTimestamp(i)),
                                        action: s,
                                        actionCount: e.count,
                                        actionDuration: e.relativeMs[e.relativeMs.length - 1],
                                        actionMs: e.relativeMs,
                                        rageClick: e.rageClick,
                                        target: e.selectorPath,
                                        ...(0, w.v)(window) && {
                                            iframe: !0
                                        },
                                        ...t ? .id && {
                                            targetId: t.id
                                        },
                                        ...t ? .tagName && {
                                            targetTag: t.tagName
                                        },
                                        ...t ? .type && {
                                            targetType: t.type
                                        },
                                        ...t ? .className && {
                                            targetClass: t.className
                                        }
                                    })
                                }
                            } catch (e) {}
                        }, (0, f.i)("ua", (e => {
                            this.addUserAction(this.userActionAggregator.process(e))
                        }), this.featureName, this.ee), t.push(((e = {}) => {
                            e.isFinalHarvest && this.addUserAction(this.userActionAggregator.aggregationEvent)
                        }))), this.harvestScheduler = new r.n("ins", {
                            onFinished: (...e) => this.onHarvestFinished(...e)
                        }, this), this.harvestScheduler.harvest.on("ins", ((...e) => (t.forEach((t => t(...e))), this.onHarvestStarted(...e)))), this.harvestScheduler.startTimer(this.harvestTimeSeconds, 0), this.drain()
                    }))
                }
                addEvent(e = {}) {
                    if (!e || !Object.keys(e).length) return;
                    if (!e.eventType) return void(0, l.R)(44);
                    for (let t in e) {
                        let i = e[t];
                        e[t] = i && "object" == typeof i ? (0, s.A)(i) : i
                    }
                    const t = {
                            timestamp: Math.floor(this.#i.timeKeeper.correctRelativeTimestamp((0, p.t)())),
                            pageUrl: (0, n.L)("" + u.m),
                            currentUrl: (0, n.L)("" + location)
                        },
                        i = { ...(0, a.Vp)(this.agentIdentifier).jsAttributes || {},
                            ...t,
                            ...e
                        };
                    this.events.add(i), this.checkEventLimits()
                }
                onHarvestStarted(e) {
                    const {
                        userAttributes: t,
                        atts: i
                    } = (0, a.Vp)(this.agentIdentifier);
                    if (this.events.hasData) {
                        var s = {
                            qs: {
                                ua: t,
                                at: i
                            },
                            body: (0, y.G)({
                                ins: this.events.buffer
                            }, this.obfuscator.obfuscateString.bind(this.obfuscator), "string")
                        };
                        return e.retry ? this.events.hold() : this.events.clear(), s
                    }
                }
                onHarvestFinished(e) {
                    e && e ? .sent && e ? .retry && this.events.held.hasData ? this.events.unhold() : this.events.held.clear()
                }
                checkEventLimits() {
                    this.events.bytes > b.N && (this.ee.emit(g.xV, ["GenericEvents/Harvest/Max/Seen"]), this.harvestScheduler.runHarvest())
                }
            }
        },
        2823: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => C
            });
            const s = /([a-z0-9]+)$/i;

            function r(e) {
                if (!e) return;
                const t = e.match(s);
                return t ? t[1] : void 0
            }
            var n = /^\n+|\n+$/g;

            function a(e) {
                return function(e) {
                    var t;
                    if (e.length > 100) {
                        var i = e.length - 100;
                        t = e.slice(0, 50).join("\n"), t += "\n< ...truncated " + i + " lines... >\n", t += e.slice(-50).join("\n")
                    } else t = e.join("\n");
                    return t
                }(e).replace(n, "")
            }
            var o = i(6154),
                c = i(9119);

            function h(e) {
                if ("string" != typeof e) return "";
                const t = (0, c.L)(e);
                return t === (0, c.L)(o.m) ? "<inline>" : t
            }
            var u = !1,
                d = /function (.+?)\s*\(/,
                l = /^\s*at (?:((?:\[object object\])?(?:[^(]*\([^)]*\))*[^()]*(?: \[as \S+\])?) )?\(?((?:file|http|https|chrome-extension):.*?)?:(\d+)(?::(\d+))?\)?\s*$/i,
                p = /^\s*(?:(\S*|global code)(?:\(.*?\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\d+)(?::(\d+))?\s*$/i,
                f = /^\s*at .+ \(eval at \S+ \((?:(?:file|http|https):[^)]+)?\)(?:, [^:]*:\d+:\d+)?\)$/i,
                m = /^\s*at Function code \(Function code:\d+:\d+\)\s*/i;

            function g(e) {
                var t = null;
                try {
                    if (t = function(e) {
                            if (!e.stack) return null;
                            var t = e.stack.split("\n").reduce(v, {
                                frames: [],
                                stackLines: [],
                                wrapperSeen: !1
                            });
                            return t.frames.length ? {
                                mode: "stack",
                                name: e.name || y(e),
                                message: e.message,
                                stackString: a(t.stackLines),
                                frames: t.frames
                            } : null
                        }(e), t) return t
                } catch (e) {
                    u
                }
                try {
                    if (t = function(e) {
                            if (!("line" in e)) return null;
                            var t = e.name || y(e);
                            if (!e.sourceURL) return {
                                mode: "sourceline",
                                name: t,
                                message: e.message,
                                stackString: t + ": " + e.message + "\n    in evaluated code",
                                frames: [{
                                    func: "evaluated code"
                                }]
                            };
                            var i = h(e.sourceURL),
                                s = t + ": " + e.message + "\n    at " + i;
                            e.line && (s += ":" + e.line, e.column && (s += ":" + e.column));
                            return {
                                mode: "sourceline",
                                name: t,
                                message: e.message,
                                stackString: s,
                                frames: [{
                                    url: i,
                                    line: e.line,
                                    column: e.column
                                }]
                            }
                        }(e), t) return t
                } catch (e) {
                    u
                }
                try {
                    if (t = function(e) {
                            var t = e.name || y(e);
                            return t ? {
                                mode: "nameonly",
                                name: t,
                                message: e.message,
                                stackString: t + ": " + e.message,
                                frames: []
                            } : null
                        }(e), t) return t
                } catch (e) {
                    u
                }
                return {
                    mode: "failed",
                    stackString: "",
                    frames: []
                }
            }

            function v(e, t) {
                let i = function(e) {
                    var t = e.match(p);
                    t || (t = e.match(l));
                    if (t) return {
                        url: t[2],
                        func: "Anonymous function" !== t[1] && "global code" !== t[1] && t[1] || null,
                        line: +t[3],
                        column: t[4] ? +t[4] : null
                    };
                    if (e.match(f) || e.match(m) || "anonymous" === e) return {
                        func: "evaluated code"
                    }
                }(t);
                if (!i) return e.stackLines.push(t), e;
                var s;
                if ((s = i.func) && s.indexOf("nrWrapper") >= 0 && (e.wrapperSeen = !0), !e.wrapperSeen) {
                    let s = h(i.url);
                    s !== i.url && (t = t.replace(i.url, s), i.url = s), e.stackLines.push(t), e.frames.push(i)
                }
                return e
            }

            function y(e) {
                var t = d.exec(String(e.constructor));
                return t && t.length > 1 ? t[1] : "unknown"
            }

            function b(e) {
                var t = 0;
                if (!e || !e.length) return t;
                for (var i = 0; i < e.length; i++) t = (t << 5) - t + e.charCodeAt(i), t |= 0;
                return t
            }
            var T = i(3606),
                S = i(1140),
                w = i(3304),
                E = i(9908),
                I = i(2555),
                R = i(9417),
                A = i(3371),
                x = i(6774),
                M = i(860),
                N = i(5942),
                k = i(384),
                F = i(1687),
                j = i(1863),
                O = i(3311);
            class C extends N.r {
                static featureName = x.T;
                constructor(e, t) {
                    super(e, t, x.T), this.stackReported = {}, this.observedAt = {}, this.pageviewReported = {}, this.bufferedErrorsUnderSpa = {}, this.currentBody = void 0, this.errorOnPage = !1, this.ee.on("interactionDone", ((e, t) => this.onInteractionDone(e, t))), (0, T.i)("err", ((...e) => this.storeError(...e)), this.featureName, this.ee), (0, T.i)("ierr", ((...e) => this.storeError(...e)), this.featureName, this.ee), (0, T.i)("softNavFlush", ((e, t, i) => this.onSoftNavNotification(e, t, i)), this.featureName, this.ee);
                    const i = (0, R.gD)(this.agentIdentifier, "jserrors.harvestTimeSeconds") || 10;
                    this.waitForFlags(["err"]).then((([e]) => {
                        if (e) {
                            const e = new S.n("jserrors", {
                                onFinished: (...e) => this.onHarvestFinished(...e)
                            }, this);
                            e.harvest.on("jserrors", ((...e) => this.onHarvestStarted(...e))), e.startTimer(i), this.drain()
                        } else this.blocked = !0, (0, F.x3)(this.agentIdentifier, this.featureName)
                    }))
                }
                onHarvestStarted(e) {
                    var t = (0, O.G)(this.aggregator.take(["err", "ierr", "xhr"]), this.obfuscator.obfuscateString.bind(this.obfuscator), "string");
                    e.retry && (this.currentBody = t);
                    var i = {
                            body: t,
                            qs: {}
                        },
                        s = (0, w.A)((0, A.f)(this.agentIdentifier).releaseIds);
                    return "{}" !== s && (i.qs.ri = s), t && t.err && t.err.length && (this.#o(t.err), this.errorOnPage || (i.qs.pve = "1", this.errorOnPage = !0)), i
                }
                onHarvestFinished(e) {
                    e.retry && this.currentBody && (Object.entries(this.currentBody || {}).forEach((([e, t]) => {
                        for (var i = 0; i < t.length; i++) {
                            var s = t[i],
                                r = this.getBucketName(e, s.params, s.custom);
                            this.aggregator.merge(e, r, s.metrics, s.params, s.custom)
                        }
                    })), this.currentBody = null)
                }
                nameHash(e) {
                    return b("".concat(e.exceptionClass, "_").concat(e.message, "_").concat(e.stack_trace || e.browser_stack_hash))
                }
                getBucketName(e, t, i) {
                    return "xhr" === e ? b((0, w.A)(t)) + ":" + b((0, w.A)(i)) : this.nameHash(t) + ":" + b((0, w.A)(i))
                }
                buildCanonicalStackString(e) {
                    for (var t = "", i = 0; i < e.frames.length; i++) {
                        var s = e.frames[i],
                            n = r(s.func);
                        t && (t += "\n"), n && (t += n + "@"), "string" == typeof s.url && (t += s.url), s.line && (t += ":" + s.line)
                    }
                    return t
                }
                storeError(e, t, i, s, r) {
                    if (!e) return;
                    t = t || (0, j.t)();
                    const n = (0, A.f)(this.agentIdentifier);
                    let a;
                    if (!i && n.onerror && (a = n.onerror(e), a && ("string" != typeof a.group || !a.group.length))) return;
                    var c = g(e);
                    const h = {
                        stackHash: b(this.buildCanonicalStackString(c)),
                        exceptionClass: c.name,
                        request_uri: o.gm ? .location.pathname
                    };
                    c.message && (h.message = "" + c.message), a ? .group && (h.errorGroup = a.group), r && (h.hasReplay = r);
                    var u, d = b("".concat(c.name, "_").concat(c.message, "_").concat(c.stackString, "_").concat(h.hasReplay ? 1 : 0));
                    this.stackReported[d] ? h.browser_stack_hash = b(c.stackString) : (this.stackReported[d] = !0, h.stack_trace = (u = c.stackString).length > 65530 ? u.substr(0, 65530) : u, this.observedAt[d] = Math.floor(n.timeKeeper.correctRelativeTimestamp(t))), h.releaseIds = (0, w.A)(n.releaseIds), this.pageviewReported[d] || (h.pageview = 1, this.pageviewReported[d] = !0), h.firstOccurrenceTimestamp = this.observedAt[d], h.timestamp = Math.floor(n.timeKeeper.correctRelativeTimestamp(t));
                    const l = [i ? "ierr" : "err", d, h, {
                        time: t
                    }, s];
                    if ((0, E.p)("trace-jserror", l, void 0, M.K.sessionTrace, this.ee), this.blocked) return;
                    e ? .__newrelic ? .[this.agentIdentifier] && (h._interactionId = e.__newrelic[this.agentIdentifier].interactionId, h._interactionNodeId = e.__newrelic[this.agentIdentifier].interactionNodeId);
                    Boolean((0, k.nY)(this.agentIdentifier) ? .features[M.K.softNav]) ? (0, E.p)("jserror", [h, t], void 0, M.K.softNav, this.ee) : (0, E.p)("spa-jserror", l, void 0, M.K.spa, this.ee), h.browserInteractionId && !h._softNavFinished ? (this.bufferedErrorsUnderSpa[h.browserInteractionId] ? ? = [], this.bufferedErrorsUnderSpa[h.browserInteractionId].push(l)) : null != h._interactionId ? (this.bufferedErrorsUnderSpa[h._interactionId] = this.bufferedErrorsUnderSpa[h._interactionId] || [], this.bufferedErrorsUnderSpa[h._interactionId].push(l)) : this.#c(l, void 0 !== h.browserInteractionId, h._softNavAttributes)
                }#
                c(e, t, i = {}) {
                    let [s, r, n, a, o] = e;
                    const c = {};
                    t ? (Object.entries(i).forEach((([e, t]) => u(e, t))), r += n.browserInteractionId, delete n._softNavAttributes, delete n._softNavFinished) : (Object.entries((0, I.Vp)(this.agentIdentifier).jsAttributes).forEach((([e, t]) => u(e, t))), delete n.browserInteractionId), o && Object.entries(o).forEach((([e, t]) => u(e, t)));
                    const h = r + ":" + b((0, w.A)(c));

                    function u(e, t) {
                        c[e] = t && "object" == typeof t ? (0, w.A)(t) : t
                    }
                    this.aggregator.store(s, h, n, a, c)
                }
                onInteractionDone(e, t) {
                    this.bufferedErrorsUnderSpa[e.id] && !this.blocked && (this.bufferedErrorsUnderSpa[e.id].forEach((i => {
                        var s = {};
                        const r = i[4];
                        Object.entries(e.root.attrs.custom || {}).forEach(o), Object.entries(r || {}).forEach(o);
                        var n = i[2];
                        t && (n.browserInteractionId = e.root.attrs.id, n._interactionNodeId && (n.parentNodeId = n._interactionNodeId.toString())), delete n._interactionId, delete n._interactionNodeId;
                        var a = (t ? i[1] + e.root.attrs.id : i[1]) + ":" + b((0, w.A)(s));

                        function o([e, t]) {
                            s[e] = t && "object" == typeof t ? (0, w.A)(t) : t
                        }
                        this.aggregator.store(i[0], a, n, i[3], s)
                    })), delete this.bufferedErrorsUnderSpa[e.id])
                }
                onSoftNavNotification(e, t, i) {
                    this.blocked || (this.bufferedErrorsUnderSpa[e] ? .forEach((e => this.#c(e, t, i))), delete this.bufferedErrorsUnderSpa[e])
                }#
                o(e) {
                    const t = {
                        errorHashes: e.map((e => e.params.stackHash))
                    };
                    this.ee.emit("cfc.".concat(this.featureName), [t]), e.find((e => e.params.hasReplay)) && !t.hasReplay && e.forEach((e => {
                        delete e.params.hasReplay
                    }))
                }
            }
        },
        5288: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => S
            });
            var s = i(2555),
                r = i(9417),
                n = i(3371),
                a = i(9908),
                o = i(3606),
                c = i(1140),
                h = i(944),
                u = i(3304),
                d = i(3969),
                l = i(5942),
                p = i(993),
                f = i(6154),
                m = i(9119);
            class g {
                timestamp;
                message;
                attributes;
                level;
                constructor(e, t, i = {}, s = p.p_.INFO) {
                    this.timestamp = e, this.message = t, this.attributes = { ...i,
                        pageUrl: (0, m.L)("" + f.gm.location)
                    }, this.level = s.toUpperCase()
                }
            }
            var v = i(3785),
                y = i(3311),
                b = i(7699),
                T = i(8771);
            class S extends l.r {
                static featureName = p.TZ;#
                i;#
                t;
                constructor(e, t) {
                    super(e, t, p.TZ), this.bufferedLogs = new T.Z, this.#i = (0, n.f)(this.agentIdentifier), this.#t = (0, s.Vp)(this.agentIdentifier), this.harvestTimeSeconds = (0, r.gD)(this.agentIdentifier, "logging.harvestTimeSeconds"), this.waitForFlags([]).then((() => {
                        this.scheduler = new c.n("browser/logs", {
                            onFinished: this.onHarvestFinished.bind(this),
                            retryDelay: this.harvestTimeSeconds,
                            getPayload: this.prepareHarvest.bind(this),
                            raw: !0
                        }, this), (0, o.i)(p.ET, this.handleLog.bind(this), this.featureName, this.ee), this.drain(), this.scheduler.startTimer(this.harvestTimeSeconds, 0)
                    }))
                }
                handleLog(e, t, i = {}, s = p.p_.INFO) {
                    if (this.blocked) return;
                    if (i && "object" == typeof i || (i = {}), "string" == typeof s && (s = s.toUpperCase()), !(0, v.b)(s)) return (0, h.R)(30, s);
                    try {
                        if ("string" != typeof t) {
                            const e = (0, u.A)(t);
                            t = e && "{}" !== e ? e : String(t)
                        }
                    } catch (e) {
                        return void(0, h.R)(16, t)
                    }
                    if ("string" != typeof t || !t) return (0, h.R)(32);
                    const r = new g(Math.floor(this.#i.timeKeeper.correctRelativeTimestamp(e)), t, i, s),
                        n = r.message.length + (0, u.A)(r.attributes).length + r.level.length + 10;
                    this.bufferedLogs.canMerge(n) ? this.bufferedLogs.add(r) : this.bufferedLogs.hasData ? ((0, a.p)(d.xV, ["Logging/Harvest/Early/Seen", this.bufferedLogs.bytes + n]), this.scheduler.runHarvest({}), n < b.I && this.bufferedLogs.add(r)) : ((0, a.p)(d.xV, ["Logging/Harvest/Failed/Seen", n]), (0, h.R)(31, r.message.slice(0, 25) + "..."))
                }
                prepareHarvest(e = {}) {
                    if (this.blocked || !this.bufferedLogs.hasData) return;
                    const t = {
                        qs: {
                            browser_monitoring_key: this.#t.licenseKey
                        },
                        body: [{
                            common: {
                                attributes: {
                                    "entity.guid": this.#i.appMetadata ? .agents ? .[0] ? .entityGuid,
                                    session: this.#i ? .session ? .state.value || "0",
                                    hasReplay: 1 === this.#i ? .session ? .state.sessionReplayMode,
                                    hasTrace: 1 === this.#i ? .session ? .state.sessionTraceMode,
                                    ptid: this.#i.ptid,
                                    appId: this.#t.applicationID,
                                    standalone: Boolean(this.#t.sa),
                                    agentVersion: this.#i.version
                                }
                            },
                            logs: (0, y.G)(this.bufferedLogs.buffer, this.obfuscator.obfuscateString.bind(this.obfuscator), "string")
                        }]
                    };
                    return e.retry ? this.bufferedLogs.hold() : this.bufferedLogs.clear(), t
                }
                onHarvestFinished(e) {
                    e.retry ? this.bufferedLogs.unhold() : this.bufferedLogs.held.clear()
                }
            }
        },
        8351: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => D
            });
            var s = i(9417),
                r = i(3371),
                n = i(3606),
                a = i(1140),
                o = i(3969),
                c = i(6154);
            const h = "React",
                u = "NextJS",
                d = "Vue",
                l = "NuxtJS",
                p = "Angular",
                f = "AngularUniversal",
                m = "Svelte",
                g = "SvelteKit",
                v = "Preact",
                y = "PreactSSR",
                b = "AngularJS",
                T = "Backbone",
                S = "Ember",
                w = "Meteor",
                E = "Zepto",
                I = "Jquery",
                R = "MooTools",
                A = "Qwik",
                x = "Electron";

            function M() {
                if (!c.RI) return [];
                const e = [];
                try {
                    (function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "React") || Object.prototype.hasOwnProperty.call(window, "ReactDOM") || Object.prototype.hasOwnProperty.call(window, "ReactRedux") || document.querySelector("[data-reactroot], [data-reactid]") || (() => {
                                const e = document.querySelectorAll("body > div");
                                for (let t = 0; t < e.length; t++)
                                    if (Object.prototype.hasOwnProperty.call(e[t], "_reactRootContainer")) return !0
                            })()
                        } catch (e) {
                            return !1
                        }
                    })() && (e.push(h), function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "next") && Object.prototype.hasOwnProperty.call(window.next, "version")
                        } catch (e) {
                            return !1
                        }
                    }() && e.push(u)),
                    function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "Vue")
                        } catch (e) {
                            return !1
                        }
                    }() && (e.push(d), function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "$nuxt") && Object.prototype.hasOwnProperty.call(window.$nuxt, "nuxt")
                        } catch (e) {
                            return !1
                        }
                    }() && e.push(l)),
                    function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "ng") || document.querySelector("[ng-version]")
                        } catch (e) {
                            return !1
                        }
                    }() && (e.push(p), function() {
                        try {
                            return document.querySelector("[ng-server-context]")
                        } catch (e) {
                            return !1
                        }
                    }() && e.push(f)),
                    function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "__svelte")
                        } catch (e) {
                            return !1
                        }
                    }() && (e.push(m), function() {
                        try {
                            return !!Object.keys(window).find((e => e.startsWith("__sveltekit")))
                        } catch (e) {
                            return !1
                        }
                    }() && e.push(g)),
                    function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "preact")
                        } catch (e) {
                            return !1
                        }
                    }() && (e.push(v), function() {
                        try {
                            return document.querySelector('script[type="__PREACT_CLI_DATA__"]')
                        } catch (e) {
                            return !1
                        }
                    }() && e.push(y)),
                    function() {
                        try {
                            return Object.prototype.hasOwnProperty.call(window, "angular") || document.querySelector(".ng-binding, [ng-app], [data-ng-app], [ng-controller], [data-ng-controller], [ng-repeat], [data-ng-repeat]") || document.querySelector('script[src*="angular.js"], script[src*="angular.min.js"]')
                        } catch (e) {
                            return !1
                        }
                    }() && e.push(b), Object.prototype.hasOwnProperty.call(window, "Backbone") && e.push(T), Object.prototype.hasOwnProperty.call(window, "Ember") && e.push(S), Object.prototype.hasOwnProperty.call(window, "Meteor") && e.push(w), Object.prototype.hasOwnProperty.call(window, "Zepto") && e.push(E), Object.prototype.hasOwnProperty.call(window, "jQuery") && e.push(I), Object.prototype.hasOwnProperty.call(window, "MooTools") && e.push(R), Object.prototype.hasOwnProperty.call(window, "qwikevents") && e.push(A),
                        function() {
                            try {
                                return "object" == typeof navigator && "string" == typeof navigator.userAgent && navigator.userAgent.indexOf("Electron") >= 0
                            } catch (e) {
                                return !1
                            }
                        }() && e.push(x)
                } catch (e) {}
                return e
            }
            var N = i(4284),
                k = i(5289),
                F = i(3878),
                j = i(5942),
                O = i(1687),
                C = i(2123);
            class D extends j.r {
                static featureName = o.TZ;
                constructor(e, t) {
                    super(e, t, o.TZ), this.waitForFlags(["err"]).then((([e]) => {
                        if (e) {
                            new a.n("jserrors", {
                                onUnload: () => this.unload()
                            }, this).harvest.on("jserrors", (() => ({
                                body: this.aggregator.take(["cm", "sm"])
                            }))), this.drain()
                        } else this.blocked = !0, (0, O.x3)(this.agentIdentifier, this.featureName)
                    })), (0, n.i)(o.xV, this.storeSupportabilityMetrics.bind(this), this.featureName, this.ee), (0, n.i)(o.XG, this.storeEventMetrics.bind(this), this.featureName, this.ee), this.singleChecks(), this.eachSessionChecks()
                }
                storeSupportabilityMetrics(e, t) {
                    if (this.blocked) return;
                    const i = o.rs,
                        s = {
                            name: e
                        };
                    this.aggregator.storeMetric(i, e, s, t)
                }
                storeEventMetrics(e, t) {
                    if (this.blocked) return;
                    const i = o.z_,
                        s = {
                            name: e
                        };
                    this.aggregator.store(i, e, s, t)
                }
                singleChecks() {
                    const {
                        distMethod: e,
                        loaderType: t
                    } = (0, r.f)(this.agentIdentifier), {
                        proxy: i,
                        privacy: n
                    } = (0, s.D0)(this.agentIdentifier);
                    if (t && this.storeSupportabilityMetrics("Generic/LoaderType/".concat(t, "/Detected")), e && this.storeSupportabilityMetrics("Generic/DistMethod/".concat(e, "/Detected")), c.RI) {
                        this.storeSupportabilityMetrics("Generic/Runtime/Browser/Detected");
                        const e = document ? .currentScript ? .nonce;
                        e && "" !== e && this.storeSupportabilityMetrics("Generic/Runtime/Nonce/Detected"), (0, k.sB)((() => {
                            M().forEach((e => {
                                this.storeSupportabilityMetrics("Framework/" + e + "/Detected")
                            }))
                        })), n.cookies_enabled || this.storeSupportabilityMetrics("Config/SessionTracking/Disabled")
                    } else c.bv ? this.storeSupportabilityMetrics("Generic/Runtime/Worker/Detected") : this.storeSupportabilityMetrics("Generic/Runtime/Unknown/Detected");
                    (0, N.p)() && this.storeSupportabilityMetrics("Generic/FileProtocol/Detected");
                    const a = this.obfuscator.ruleValidationCache;
                    if (a.length > 0 && (this.storeSupportabilityMetrics("Generic/Obfuscate/Detected"), a.filter((e => !e.isValid)).length > 0 && this.storeSupportabilityMetrics("Generic/Obfuscate/Invalid")), i.assets && this.storeSupportabilityMetrics("Config/AssetsUrl/Changed"), i.beacon && this.storeSupportabilityMetrics("Config/BeaconUrl/Changed"), c.RI && window.MutationObserver) {
                        (0, C.v)(window) && this.storeSupportabilityMetrics("Generic/Runtime/IFrame/Detected");
                        const e = window.document.querySelectorAll("video").length;
                        e && this.storeSupportabilityMetrics("Generic/VideoElement/Added", e);
                        const t = window.document.querySelectorAll("iframe").length;
                        t && this.storeSupportabilityMetrics("Generic/IFrame/Added", t);
                        new MutationObserver((e => {
                            e.forEach((e => {
                                e.addedNodes.forEach((e => {
                                    e instanceof HTMLVideoElement && this.storeSupportabilityMetrics("Generic/VideoElement/Added", 1), e instanceof HTMLIFrameElement && this.storeSupportabilityMetrics("Generic/IFrame/Added", 1)
                                }))
                            }))
                        })).observe(window.document.body, {
                            childList: !0,
                            subtree: !0
                        })
                    }
                }
                eachSessionChecks() {
                    c.RI && (0, F.sp)("pageshow", (e => {
                        e ? .persisted && this.storeSupportabilityMetrics("Generic/BFCache/PageRestored")
                    }))
                }
                unload() {
                    try {
                        if (this.resourcesSent) return;
                        this.resourcesSent = !0;
                        const e = ["beacon", "fetch", "xmlhttprequest"],
                            t = ["nr-data.net", "newrelic.com", "nr-local.net", "localhost"];

                        function i(t) {
                            return e.includes(t.initiatorType)
                        }
                        if ((performance ? .getEntriesByType("resource") || []).forEach((e => {
                                var s;
                                s = e, t.some((e => s.name.indexOf(e) >= 0)) ? i(e) ? this.storeSupportabilityMetrics("Generic/Resources/Ajax/Internal") : this.storeSupportabilityMetrics("Generic/Resources/Non-Ajax/Internal") : i(e) ? this.storeSupportabilityMetrics("Generic/Resources/Ajax/External") : this.storeSupportabilityMetrics("Generic/Resources/Non-Ajax/External")
                            })), "undefined" != typeof performance) {
                            const s = performance.getEntriesByType("mark"),
                                r = performance.getEntriesByType("measure");
                            s.length && this.storeSupportabilityMetrics("Generic/Performance/Mark/Seen", s.length), r.length && this.storeSupportabilityMetrics("Generic/Performance/Measure/Seen", r.length)
                        }
                    } catch (n) {}
                }
            }
        },
        1983: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => w
            });
            var s = i(6154),
                r = i(2733),
                n = i(3304),
                a = i(2555),
                o = i(3371),
                c = i(4624),
                h = i(6630),
                u = i(860),
                d = i(384);

            function l(e) {
                const t = [],
                    i = (0, d.Zm)();
                try {
                    Object.keys(i.initializedAgents[e].features).forEach((e => {
                        switch (e) {
                            case u.K.ajax:
                                t.push("xhr");
                                break;
                            case u.K.jserrors:
                                t.push("err");
                                break;
                            case u.K.genericEvents:
                                t.push("ins");
                                break;
                            case u.K.sessionTrace:
                                t.push("stn");
                                break;
                            case u.K.softNav:
                            case u.K.spa:
                                t.push("spa")
                        }
                    }))
                } catch (e) {}
                return t
            }
            var p = i(5284),
                f = i(944),
                m = i(5942),
                g = i(5344),
                v = i(5181),
                y = i(8779),
                b = i(1863);
            class T {#
                h;#
                u;#
                d;#
                l = !1;
                constructor(e) {
                    this.#h = (0, o.f)(e) ? .session, this.processStoredDiff()
                }
                get ready() {
                    return this.#l
                }
                get correctedOriginTime() {
                    return this.#u
                }
                get localTimeDiff() {
                    return this.#d
                }
                processRumRequest(e, t, i, r) {
                    if (this.processStoredDiff(), this.#l) return;
                    if (!r) throw new Error("nrServerTime not found");
                    const n = t + (i - t) / 2;
                    if (this.#u = Math.floor(r - n), this.#d = s.WN - this.#u, isNaN(this.#u)) throw new Error("Failed to correct browser time to server time");
                    this.#h ? .write({
                        serverTimeDiff: this.#d
                    }), this.#l = !0
                }
                convertRelativeTimestamp(e) {
                    return s.WN + e
                }
                convertAbsoluteTimestamp(e) {
                    return e - s.WN
                }
                correctAbsoluteTimestamp(e) {
                    return e - this.#d
                }
                correctRelativeTimestamp(e) {
                    return this.correctAbsoluteTimestamp(this.convertRelativeTimestamp(e))
                }
                processStoredDiff() {
                    if (this.#l) return;
                    const e = this.#h ? .read() ? .serverTimeDiff;
                    "number" != typeof e || isNaN(e) || (this.#d = e, this.#u = s.WN - this.#d, this.#l = !0)
                }
            }
            var S = i(3311);
            class w extends m.r {
                static featureName = h.T;
                constructor(e, t) {
                    if (super(e, t, h.T), this.timeToFirstByte = 0, this.firstByteToWindowLoad = 0, this.firstByteToDomContent = 0, this.timeKeeper = new T(this.agentIdentifier), !(0, a.fn)(e)) return this.ee.abort(), (0, f.R)(43);
                    s.RI ? y.j.subscribe((({
                        value: e,
                        attrs: t
                    }) => {
                        const i = t.navigationEntry;
                        this.timeToFirstByte = Math.max(e, this.timeToFirstByte), this.firstByteToWindowLoad = Math.max(Math.round(i.loadEventEnd - this.timeToFirstByte), this.firstByteToWindowLoad), this.firstByteToDomContent = Math.max(Math.round(i.domContentLoadedEventEnd - this.timeToFirstByte), this.firstByteToDomContent), this.sendRum()
                    })) : this.sendRum()
                }
                sendRum() {
                    const e = (0, a.Vp)(this.agentIdentifier),
                        t = (0, o.f)(this.agentIdentifier),
                        i = new c.M(this);
                    e.queueTime && this.aggregator.store("measures", "qt", {
                        value: e.queueTime
                    }), e.applicationTime && this.aggregator.store("measures", "ap", {
                        value: e.applicationTime
                    }), this.aggregator.store("measures", "be", {
                        value: this.timeToFirstByte
                    }), this.aggregator.store("measures", "fe", {
                        value: this.firstByteToWindowLoad
                    }), this.aggregator.store("measures", "dc", {
                        value: this.firstByteToDomContent
                    });
                    const h = {
                        tt: e.ttGuid,
                        us: e.user,
                        ac: e.account,
                        pr: e.product,
                        af: l(this.agentIdentifier).join(","),
                        ...Object.entries(this.aggregator.get("measures") || {}).reduce(((e, [t, i]) => (e[t] = i.params ? .value, e)), {}),
                        xx: e.extra,
                        ua: e.userAttributes,
                        at: e.atts
                    };
                    let u;
                    if (t.session && (h.fsh = Number(t.session.isNew)), "object" == typeof e.jsAttributes && Object.keys(e.jsAttributes).length > 0 && (u = (0, S.G)({
                            ja: e.jsAttributes
                        }, this.obfuscator.obfuscateString.bind(this.obfuscator), "string")), s.gm.performance)
                        if ("undefined" != typeof PerformanceNavigationTiming) {
                            const e = s.gm ? .performance ? .getEntriesByType("navigation") ? .[0],
                                t = {
                                    timing: (0, r.eM)(s.WN, e, {}),
                                    navigation: (0, r.si)(e, {})
                                };
                            h.perf = (0, n.A)(t)
                        } else if ("undefined" != typeof PerformanceTiming) {
                        const e = {
                            timing: (0, r.eM)(s.WN, s.gm.performance.timing, {}, !0),
                            navigation: (0, r.si)(s.gm.performance.navigation, {})
                        };
                        h.perf = (0, n.A)(e)
                    }
                    h.fp = v.J.current.value, h.fcp = g.j.current.value, this.timeKeeper ? .ready && (h.timestamp = Math.floor(this.timeKeeper.correctRelativeTimestamp((0, b.t)())));
                    const d = (0, b.t)();
                    i.send({
                        endpoint: "rum",
                        payload: {
                            qs: h,
                            body: u
                        },
                        opts: {
                            needResponse: !0,
                            sendEmptyBody: !0
                        },
                        cbFinished: ({
                            status: e,
                            responseText: i,
                            xhr: s
                        }) => {
                            const r = (0, b.t)();
                            if (e >= 400 || 0 === e) this.ee.abort();
                            else try {
                                const {
                                    app: e,
                                    ...n
                                } = JSON.parse(i);
                                try {
                                    if (this.timeKeeper.processRumRequest(s, d, r, e.nrServerTime), !this.timeKeeper.ready) throw new Error("TimeKeeper not ready");
                                    t.timeKeeper = this.timeKeeper
                                } catch (e) {
                                    return this.ee.abort(), void(0, f.R)(17, e)
                                }
                                t.appMetadata = e, (0, p.t)(n, this.agentIdentifier), this.drain()
                            } catch (e) {
                                this.ee.abort(), (0, f.R)(18, e)
                            }
                        }
                    })
                }
            }
        },
        5999: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => A
            });
            var s = i(5519),
                r = i(1140),
                n = i(3606),
                a = i(9908),
                o = i(2555),
                c = i(9417),
                h = i(782),
                u = i(860),
                d = i(5942),
                l = i(7226),
                p = i(1083),
                f = i(6773),
                m = i(6154);
            const g = new f.x(p.w.CUMULATIVE_LAYOUT_SHIFT, (e => e));
            m.RI && (0, l.IN)((({
                value: e,
                attribution: t,
                id: i
            }) => {
                const s = {
                    metricId: i,
                    largestShiftTarget: t.largestShiftTarget,
                    largestShiftTime: t.largestShiftTime,
                    largestShiftValue: t.largestShiftValue,
                    loadState: t.loadState
                };
                g.update({
                    value: e,
                    attrs: s
                })
            }), {
                reportAllChanges: !0
            });
            var v = i(5344);
            const y = new f.x(p.w.FIRST_INPUT_DELAY);
            m.RI && (0, l.lt)((({
                value: e,
                attribution: t
            }) => {
                if (m.mw || y.isValid) return;
                const i = {
                    type: t.eventType,
                    fid: Math.round(e),
                    eventTarget: t.eventTarget,
                    loadState: t.loadState
                };
                y.update({
                    value: t.eventTime,
                    attrs: i
                })
            }));
            var b = i(5181);
            const T = new f.x(p.w.INTERACTION_TO_NEXT_PAINT);
            m.RI && (0, l.rH)((({
                value: e,
                attribution: t,
                id: i
            }) => {
                const s = {
                    metricId: i,
                    eventTarget: t.interactionTarget,
                    eventTime: t.interactionTime,
                    interactionTarget: t.interactionTarget,
                    interactionTime: t.interactionTime,
                    interactionType: t.interactionType,
                    inputDelay: t.inputDelay,
                    nextPaintTime: t.nextPaintTime,
                    processingDuration: t.processingDuration,
                    presentationDelay: t.presentationDelay,
                    loadState: t.loadState
                };
                T.update({
                    value: e,
                    attrs: s
                })
            }));
            var S = i(9119);
            const w = new f.x(p.w.LARGEST_CONTENTFUL_PAINT);
            m.RI && (0, l.fK)((({
                value: e,
                attribution: t
            }) => {
                if (m.mw || w.isValid) return;
                let i;
                const s = t.lcpEntry;
                s && (i = {
                    size: s.size,
                    eid: s.id,
                    element: t.element,
                    timeToFirstByte: t.timeToFirstByte,
                    resourceLoadDelay: t.resourceLoadDelay,
                    resourceLoadDuration: t.resourceLoadDuration,
                    resourceLoadTime: t.resourceLoadDuration,
                    elementRenderDelay: t.elementRenderDelay
                }, t.url && (i.elUrl = (0, S.L)(t.url)), s.element ? .tagName && (i.elTag = s.element.tagName)), w.update({
                    value: e,
                    attrs: i
                })
            }));
            var E = i(8779),
                I = i(2843),
                R = i(8771);
            class A extends d.r {
                static featureName = h.T;#
                p = ({
                    name: e,
                    value: t,
                    attrs: i
                }) => {
                    this.addTiming(e, t, i)
                };
                constructor(e, t) {
                    super(e, t, h.T), this.timings = new R.Z, this.curSessEndRecorded = !1, (0, n.i)("docHidden", (e => this.endCurrentSession(e)), this.featureName, this.ee), (0, n.i)("winPagehide", (e => this.recordPageUnload(e)), this.featureName, this.ee);
                    const i = (0, c.gD)(this.agentIdentifier, "page_view_timing.harvestTimeSeconds") || 30;
                    this.waitForFlags([]).then((() => {
                        b.J.subscribe(this.#p), v.j.subscribe(this.#p), y.subscribe(this.#p), w.subscribe(this.#p), T.subscribe(this.#p), E.j.subscribe((({
                            attrs: e
                        }) => {
                            this.addTiming("load", Math.round(e.navigationEntry.loadEventEnd))
                        })), (0, I.u)((() => {
                            const {
                                name: e,
                                value: t,
                                attrs: i
                            } = g.current;
                            void 0 !== t && this.addTiming(e, 1e3 * t, i)
                        }), !0);
                        new r.n("events", {
                            onFinished: (...e) => this.onHarvestFinished(...e),
                            getPayload: (...e) => this.prepareHarvest(...e)
                        }, this).startTimer(i), this.drain()
                    }))
                }
                endCurrentSession(e) {
                    this.curSessEndRecorded || (this.addTiming("pageHide", e, null), this.curSessEndRecorded = !0)
                }
                recordPageUnload(e) {
                    this.addTiming("unload", e, null), this.endCurrentSession(e)
                }
                addTiming(e, t, i) {
                    (function(e) {
                        var t = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                        if (!t) return;
                        t.type && (e["net-type"] = t.type);
                        t.effectiveType && (e["net-etype"] = t.effectiveType);
                        t.rtt && (e["net-rtt"] = t.rtt);
                        t.downlink && (e["net-dlink"] = t.downlink)
                    })(i = i || {}), e !== p.w.CUMULATIVE_LAYOUT_SHIFT && g.current.value >= 0 && (i.cls = g.current.value), this.timings.add({
                        name: e,
                        value: t,
                        attrs: i
                    }), (0, a.p)("pvtAdded", [e, t, i], void 0, u.K.sessionTrace, this.ee)
                }
                onHarvestFinished(e) {
                    e.retry && this.timings.held.hasData ? this.timings.unhold() : this.timings.held.clear()
                }
                appendGlobalCustomAttributes(e) {
                    var t = e.attrs || {},
                        i = (0, o.Vp)(this.agentIdentifier).jsAttributes || {},
                        s = ["size", "eid", "cls", "type", "fid", "elTag", "elUrl", "net-type", "net-etype", "net-rtt", "net-dlink"];
                    Object.entries(i || {}).forEach((([e, i]) => {
                        s.indexOf(e) < 0 && (t[e] = i)
                    }))
                }
                prepareHarvest(e) {
                    if (this.timings.hasData) {
                        var t = this.getPayload(this.timings.buffer);
                        return e.retry ? this.timings.hold() : this.timings.clear(), {
                            body: {
                                e: t
                            }
                        }
                    }
                }
                getPayload(e) {
                    for (var t = (0, s.uJ)(this.agentIdentifier), i = "bel.6;", r = 0; r < e.length; r++) {
                        var n = e[r];
                        i += "e,", i += t(n.name) + ",", i += (0, s.me)(n.value, s.sH, !1) + ",", this.appendGlobalCustomAttributes(n);
                        var a = (0, s.AQ)(n.attrs, t);
                        a && a.length > 0 && (i += (0, s.sH)(a.length) + ";" + a.join(";")), r + 1 < e.length && (i += ";")
                    }
                    return i
                }
            }
        },
        6167: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => M
            });
            var s = i(3606),
                r = i(1140),
                n = i(6344),
                a = i(2555),
                o = i(9417),
                c = i(3371),
                h = i(5942);
            let u;
            const d = new Promise((e => {
                    u = e
                })),
                l = Object.freeze({
                    onReplayReady: u,
                    sessionReplayInitialized: d
                });
            var p = i(3762),
                f = i(944),
                m = i(6154),
                g = i(3969),
                v = i(9908),
                y = i(860),
                b = i(9324),
                T = i(2614),
                S = i(3304),
                w = i(5851),
                E = i(1687),
                I = i(1863),
                R = i(5270),
                A = i(7699),
                x = i(9119);
            class M extends h.r {
                static featureName = n.TZ;
                mode = T.g.OFF;
                constructor(e, t, i) {
                    super(e, t, n.TZ), this.harvestTimeSeconds = (0, o.gD)(this.agentIdentifier, "session_replay.harvestTimeSeconds") || 60, this.initialized = !1, this.blocked = !1, this.gzipper = void 0, this.u8 = void 0, this.entitled = !1, this.timeKeeper = void 0, this.recorder = i ? .recorder, this.errorNoticed = i ? .errorNoticed || !1, (0, v.p)(g.xV, ["Config/SessionReplay/Enabled"], void 0, y.K.metrics, this.ee), this.ee.on("cfc.".concat(y.K.jserrors), (e => {
                        e.hasReplay = !(!this.scheduler ? .started || !this.recorder || this.mode !== T.g.FULL || this.blocked || !this.entitled)
                    })), this.ee.on(T.tS.RESET, (() => {
                        this.abort(n.bc.RESET)
                    })), this.ee.on(T.tS.PAUSE, (() => {
                        this.recorder ? .stopRecording()
                    })), this.ee.on(T.tS.RESUME, (() => {
                        if (!this.recorder) return;
                        const {
                            session: e
                        } = (0, c.f)(this.agentIdentifier);
                        this.mode = e.state.sessionReplayMode, this.initialized && this.mode !== T.g.OFF && this.recorder ? .startRecording()
                    })), this.ee.on(T.tS.UPDATE, ((e, t) => {
                        this.recorder && this.initialized && !this.blocked && e === T.iL.CROSS_TAB && (this.mode !== T.g.OFF && t.sessionReplayMode === T.g.OFF && this.abort(n.bc.CROSS_TAB), this.mode = t.sessionReplay)
                    })), this.scheduler = new r.n("browser/blobs", {
                        onFinished: this.onHarvestFinished.bind(this),
                        retryDelay: this.harvestTimeSeconds,
                        getPayload: this.prepareHarvest.bind(this),
                        raw: !0
                    }, this), (0, s.i)(n.G4.PAUSE, (() => {
                        this.forceStop(this.mode !== T.g.ERROR)
                    }), this.featureName, this.ee), (0, s.i)(n.G4.ERROR_DURING_REPLAY, (e => {
                        this.handleError(e)
                    }), this.featureName, this.ee);
                    const {
                        error_sampling_rate: a,
                        sampling_rate: h,
                        autoStart: u,
                        block_selector: d,
                        mask_text_selector: p,
                        mask_all_inputs: f,
                        inline_images: m,
                        collect_fonts: b
                    } = (0, o.gD)(this.agentIdentifier, "session_replay");
                    this.waitForFlags(["srs", "sr"]).then((([e, t]) => {
                        if (this.entitled = !!t, !this.entitled) return (0, E.x3)(this.agentIdentifier, this.featureName), void(this.recorder ? .recording && (this.abort(n.bc.ENTITLEMENTS), (0, v.p)(g.xV, ["SessionReplay/EnabledNotEntitled/Detected"], void 0, y.K.metrics, this.ee)));
                        this.drain(), this.initializeRecording(e)
                    })).then((() => {
                        if (this.mode === T.g.OFF)
                            for (this.recorder ? .stopRecording(); this.recorder ? .getEvents().events.length;) this.recorder ? .clearBuffer ? .();
                        l.onReplayReady(this.mode)
                    })), u || (0, v.p)(g.xV, ["Config/SessionReplay/AutoStart/Modified"], void 0, y.K.metrics, this.ee), !0 === b && (0, v.p)(g.xV, ["Config/SessionReplay/CollectFonts/Modified"], void 0, y.K.metrics, this.ee), !0 === m && (0, v.p)(g.xV, ["Config/SessionReplay/InlineImages/Modifed"], void 0, y.K.metrics, this.ee), !0 !== f && (0, v.p)(g.xV, ["Config/SessionReplay/MaskAllInputs/Modified"], void 0, y.K.metrics, this.ee), "[data-nr-block]" !== d && (0, v.p)(g.xV, ["Config/SessionReplay/BlockSelector/Modified"], void 0, y.K.metrics, this.ee), "*" !== p && (0, v.p)(g.xV, ["Config/SessionReplay/MaskTextSelector/Modified"], void 0, y.K.metrics, this.ee), (0, v.p)(g.xV, ["Config/SessionReplay/SamplingRate/Value", h], void 0, y.K.metrics, this.ee), (0, v.p)(g.xV, ["Config/SessionReplay/ErrorSamplingRate/Value", a], void 0, y.K.metrics, this.ee)
                }
                handleError(e) {
                    this.recorder && (this.recorder.currentBufferTarget.hasError = !0), this.mode === T.g.ERROR && "visible" === m.gm ? .document.visibilityState && this.switchToFull()
                }
                switchToFull() {
                    this.entitled && !this.blocked && (this.mode = T.g.FULL, this.recorder && this.initialized ? (this.recorder.recording || this.recorder.startRecording(), this.scheduler.startTimer(this.harvestTimeSeconds), this.syncWithSessionManager({
                        sessionReplayMode: this.mode
                    })) : this.initializeRecording(!1, !0, !0))
                }
                async initializeRecording(e, t) {
                    if (this.initialized = !0, !this.entitled) return;
                    const {
                        session: s,
                        timeKeeper: r
                    } = (0, c.f)(this.agentIdentifier);
                    if (this.timeKeeper = r, this.recorder ? .parent.trigger === n.Qb.API && this.recorder ? .recording ? this.mode = T.g.FULL : s.isNew || t ? this.mode = e : this.mode = s.state.sessionReplayMode, this.mode !== T.g.OFF) {
                        if (this.recorder) this.recorder.parent = this;
                        else try {
                            const {
                                Recorder: e
                            } = await Promise.all([i.e(891), i.e(222)]).then(i.bind(i, 2496));
                            this.recorder = new e(this), this.recorder.currentBufferTarget.hasError = this.errorNoticed
                        } catch (e) {
                            return this.abort(n.bc.IMPORT)
                        }
                        this.mode === T.g.ERROR && this.errorNoticed && (this.mode = T.g.FULL), this.mode === T.g.FULL && ("preloaded" === this.recorder ? .getEvents().type && this.prepUtils().then((() => {
                            this.scheduler.runHarvest()
                        })), this.scheduler.started || this.scheduler.startTimer(this.harvestTimeSeconds)), await this.prepUtils(), this.recorder.recording || this.recorder.startRecording(), this.syncWithSessionManager({
                            sessionReplayMode: this.mode
                        })
                    }
                }
                async prepUtils() {
                    try {
                        const {
                            gzipSync: e,
                            strToU8: t
                        } = await i.e(95).then(i.bind(i, 9861));
                        this.gzipper = e, this.u8 = t
                    } catch (e) {}
                }
                prepareHarvest({
                    opts: e
                } = {}) {
                    if (!this.recorder || !this.timeKeeper ? .ready || !this.recorder.hasSeenSnapshot) return;
                    const t = this.recorder.getEvents();
                    if (!t.events.length || this.mode !== T.g.FULL || this.blocked) return;
                    const i = this.getHarvestContents(t);
                    if (!i.body.length) return void this.recorder.clearBuffer();
                    (0, v.p)(g.xV, ["SessionReplay/Harvest/Attempts"], void 0, y.K.metrics, this.ee);
                    let s = 0;
                    if (this.gzipper && this.u8 ? (i.body = this.gzipper(this.u8("[".concat(i.body.map((({
                            __serialized: e,
                            ...t
                        }) => {
                            if (t.__newrelic && e) return e;
                            const i = { ...t
                            };
                            return i.__newrelic || (i.__newrelic = (0, R.CT)(t.timestamp, this.timeKeeper), i.timestamp = this.timeKeeper.correctAbsoluteTimestamp(t.timestamp)), (0, S.A)(i)
                        })).join(","), "]"))), s = i.body.length, this.scheduler.opts.gzip = !0) : (i.body = i.body.map((({
                            __serialized: e,
                            ...t
                        }) => {
                            if (t.__newrelic) return t;
                            const i = { ...t
                            };
                            return i.__newrelic = (0, R.CT)(t.timestamp, this.timeKeeper), i.timestamp = this.timeKeeper.correctAbsoluteTimestamp(t.timestamp), i
                        })), s = (0, S.A)(i.body).length, this.scheduler.opts.gzip = !1), s > A.I) return void this.abort(n.bc.TOO_BIG, s);
                    const {
                        session: r
                    } = (0, c.f)(this.agentIdentifier);
                    return r.state.sessionReplaySentFirstChunk || this.syncWithSessionManager({
                        sessionReplaySentFirstChunk: !0
                    }), this.recorder.clearBuffer(), "preloaded" === t.type && this.scheduler.runHarvest(e), [i]
                }
                getCorrectedTimestamp(e) {
                    if (e ? .timestamp) return e.__newrelic ? e.timestamp : this.timeKeeper.correctAbsoluteTimestamp(e.timestamp)
                }
                getHarvestContents(e) {
                    e ? ? = this.recorder.getEvents();
                    let t = e.events;
                    const i = (0, c.f)(this.agentIdentifier),
                        s = (0, a.Vp)(this.agentIdentifier),
                        r = s.jsAttributes ? .["enduser.id"];
                    t ? .[0] ? .type === n._s.FullSnapshot && this.recorder.lastMeta && (e.hasMeta = !0, t.unshift(this.recorder.lastMeta), this.recorder.lastMeta = void 0);
                    t[t.length - 1] ? .type === n._s.Meta && (this.recorder.lastMeta = t[t.length - 1], t = t.slice(0, t.length - 1), e.hasMeta = !!t.find((e => e.type === n._s.Meta)));
                    const o = (0, I.t)(),
                        h = this.getCorrectedTimestamp(t[0]),
                        u = this.getCorrectedTimestamp(t[t.length - 1]),
                        d = h || Math.floor(this.timeKeeper.correctAbsoluteTimestamp(e.cycleTimestamp)),
                        l = u || Math.floor(this.timeKeeper.correctRelativeTimestamp(o)),
                        f = i.appMetadata ? .agents ? .[0] || {};
                    return {
                        qs: {
                            browser_monitoring_key: s.licenseKey,
                            type: "SessionReplay",
                            app_id: s.applicationID,
                            protocol_version: "0",
                            timestamp: d,
                            attributes: (0, p.WL)({ ...!!this.gzipper && !!this.u8 && {
                                    content_encoding: "gzip"
                                },
                                ...f.entityGuid && {
                                    entityGuid: f.entityGuid
                                },
                                harvestId: [i.session ? .state.value, i.ptid, i.harvestCount].filter((e => e)).join("_"),
                                "replay.firstTimestamp": d,
                                "replay.lastTimestamp": l,
                                "replay.nodes": t.length,
                                "session.durationMs": i.session.getDuration(),
                                agentVersion: i.version,
                                session: i.session.state.value,
                                rst: o,
                                hasMeta: e.hasMeta || !1,
                                hasSnapshot: e.hasSnapshot || !1,
                                hasError: e.hasError || !1,
                                isFirstChunk: !1 === i.session.state.sessionReplaySentFirstChunk,
                                decompressedBytes: e.payloadBytesEstimation,
                                invalidStylesheetsDetected: w.m.invalidStylesheetsDetected,
                                inlinedAllStylesheets: e.inlinedAllStylesheets,
                                "rrweb.version": b.Yq,
                                "payload.type": e.type,
                                ...r && {
                                    "enduser.id": this.obfuscator.obfuscateString(r)
                                },
                                currentUrl: this.obfuscator.obfuscateString((0, x.L)("" + location))
                            }, n.BB).substring(1)
                        },
                        body: t
                    }
                }
                onHarvestFinished(e) {
                    429 === e.status && this.abort(n.bc.TOO_MANY), this.blocked && this.scheduler.stopTimer(!0)
                }
                forceStop(e) {
                    e && this.scheduler.runHarvest(), this.mode = T.g.OFF, this.recorder ? .stopRecording ? .(), this.syncWithSessionManager({
                        sessionReplayMode: this.mode
                    })
                }
                abort(e = {}, t) {
                    for ((0, f.R)(33, e.message), (0, v.p)(g.xV, ["SessionReplay/Abort/".concat(e.sm), t], void 0, y.K.metrics, this.ee), this.blocked = !0, this.mode = T.g.OFF, this.recorder ? .stopRecording ? .(), this.syncWithSessionManager({
                            sessionReplayMode: this.mode
                        }), this.recorder ? .clearTimestamps ? .(), this.ee.emit("REPLAY_ABORTED"); this.recorder ? .getEvents().events.length;) this.recorder ? .clearBuffer ? .()
                }
                syncWithSessionManager(e = {}) {
                    const {
                        session: t
                    } = (0, c.f)(this.agentIdentifier);
                    t.write(e)
                }
            }
        },
        5851: (e, t, i) => {
            i.d(t, {
                m: () => n
            });
            var s = i(384),
                r = i(6154);
            const n = new class {#
                f = new WeakSet;#
                m = [];
                invalidStylesheetsDetected = !1;
                failedToFix = 0;
                evaluate() {
                    let e = 0;
                    if (this.#m = [], r.RI)
                        for (let t = 0; t < Object.keys(document.styleSheets).length; t++)
                            if (!this.#f.has(document.styleSheets[t])) {
                                this.#f.add(document.styleSheets[t]);
                                try {
                                    document.styleSheets[t].cssRules
                                } catch (i) {
                                    if (!document.styleSheets[t].href) return;
                                    e++, this.#m.push(document.styleSheets[t])
                                }
                            }
                    return e && (this.invalidStylesheetsDetected = !0), e
                }
                async fix() {
                    await Promise.all(this.#m.map((e => this.#g(e)))), this.#m = [];
                    const e = this.failedToFix;
                    return this.failedToFix = 0, e
                }
                async# g(e) {
                    if (e ? .href) try {
                        const t = await (0, s.dV)().o.FETCH.bind(window)(e.href);
                        if (!t.ok) return void this.failedToFix++;
                        const i = await t.text();
                        try {
                            const t = new CSSStyleSheet;
                            await t.replace(i), Object.defineProperty(e, "cssRules", {
                                get: () => t.cssRules
                            }), Object.defineProperty(e, "rules", {
                                get: () => t.rules
                            })
                        } catch (t) {
                            Object.defineProperty(e, "cssText", {
                                get: () => i
                            }), this.failedToFix++
                        }
                    } catch (e) {
                        this.failedToFix++
                    }
                }
            }
        },
        575: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => E
            });
            var s = i(3606),
                r = i(1140),
                n = i(2555),
                a = i(9417),
                o = i(3371),
                c = i(3738),
                h = i(5942),
                u = i(6154),
                d = i(2614),
                l = i(1863),
                p = i(7485);
            class f {
                constructor(e, t, i, s, r) {
                    this.n = e, this.s = t, this.e = i, this.o = s, this.t = r
                }
            }
            const m = "function" == typeof u.gm.PerformanceObserver,
                g = {
                    global: {
                        mouseup: !0,
                        mousedown: !0
                    },
                    window: {
                        load: !0,
                        pagehide: !0
                    },
                    xhrOriginMissing: {
                        ignoreAll: !0
                    }
                },
                v = {
                    typing: [1e3, 2e3],
                    scrolling: [100, 1e3],
                    mousing: [1e3, 2e3],
                    touching: [1e3, 2e3]
                };
            class y {
                nodeCount = 0;
                trace = {};
                earliestTimeStamp = 1 / 0;
                latestTimeStamp = 0;
                tempStorage = [];
                prevStoredEvents = new Set;
                constructor(e) {
                    this.parent = e
                }
                storeSTN(e) {
                    if (!this.parent.blocked) {
                        if (this.nodeCount >= c.jx) {
                            if (this.parent.agentRuntime.session.state.sessionTraceMode !== d.g.ERROR) return;
                            if (0 === this.trimSTNs(3e4)) return
                        }
                        for (; this.tempStorage.length;) this.storeSTN(this.tempStorage.shift());
                        this.trace[e.n] ? this.trace[e.n].push(e) : this.trace[e.n] = [e], e.s < this.earliestTimeStamp && (this.earliestTimeStamp = e.s), e.s > this.latestTimeStamp && (this.latestTimeStamp = e.s), this.nodeCount++
                    }
                }
                trimSTNs(e) {
                    let t = 0;
                    const i = Math.max((0, l.t)() - e, 0);
                    return Object.keys(this.trace).forEach((e => {
                        const s = this.trace[e];
                        let r = s.findIndex((e => i <= e.e));
                        0 !== r && (r < 0 ? (r = s.length, delete this.trace[e]) : s.splice(0, r), this.nodeCount -= r, t += r)
                    })), t
                }
                takeSTNs() {
                    m || this.storeResources(u.gm.performance ? .getEntriesByType ? .("resource"));
                    const e = Object.entries(this.trace).flatMap((([e, t]) => {
                        if (!(e in v)) return t;
                        const i = this.smearEvtsByOrigin(e),
                            s = t.sort(((e, t) => e.s - t.s)).reduce(i, {});
                        return Object.values(s).flat()
                    }), this);
                    if (0 === e.length) return {};
                    this.trace = {}, this.nodeCount = 0;
                    const t = this.earliestTimeStamp;
                    this.earliestTimeStamp = 1 / 0;
                    const i = this.latestTimeStamp;
                    return this.latestTimeStamp = 0, {
                        stns: e,
                        earliestTimeStamp: t,
                        latestTimeStamp: i
                    }
                }
                smearEvtsByOrigin(e) {
                    const t = v[e][0],
                        i = v[e][1],
                        s = {};
                    return (r, n) => {
                        let a = r[n.o];
                        a || (a = r[n.o] = []);
                        const o = s[n.o];
                        return "scrolling" !== e || function(e) {
                            const t = 4;
                            return !!(e && "number" == typeof e.e && "number" == typeof e.s && e.e - e.s < t)
                        }(n) ? o && n.s - o.s < i && o.e > n.s - t ? o.e = n.e : (s[n.o] = n, a.push(n)) : (s[n.o] = null, n.n = "scroll", a.push(n)), r
                    }
                }
                processPVT(e, t, i) {
                    this.storeTiming({
                            [e]: t
                        }),
                        function(e, t) {
                            return "fi" === e && !!t && "number" == typeof t.fid
                        }(e, i) && this.storeEvent({
                            type: "fid",
                            target: "document"
                        }, "document", t, t + i.fid)
                }
                storeTiming(e, t = !1) {
                    if (e)
                        for (let i in e) {
                            let s = e[i];
                            const r = i.toLowerCase();
                            r.indexOf("size") >= 0 || r.indexOf("status") >= 0 || "number" == typeof s && s >= 0 && (s = Math.round(s), this.parent.timeKeeper && this.parent.timeKeeper.ready && t && (s = this.parent.timeKeeper.convertAbsoluteTimestamp(Math.floor(this.parent.timeKeeper.correctAbsoluteTimestamp(s)))), this.storeSTN(new f(i, s, s, "document", "timing")))
                        }
                }
                storeEvent(e, t, i, s) {
                    if (this.shouldIgnoreEvent(e, t)) return;
                    if (this.prevStoredEvents.has(e)) return;
                    this.prevStoredEvents.add(e);
                    const r = new f(this.evtName(e.type), i, s, void 0, "event");
                    try {
                        r.o = this.evtOrigin(e.target, t)
                    } catch (e) {
                        r.o = this.evtOrigin(null, t)
                    }
                    this.storeSTN(r)
                }
                shouldIgnoreEvent(e, t) {
                    const i = this.evtOrigin(e.target, t);
                    return e.type in g.global || (!(!g[i] || !g[i].ignoreAll) || !(!g[i] || !(e.type in g[i])))
                }
                evtName(e) {
                    switch (e) {
                        case "keydown":
                        case "keyup":
                        case "keypress":
                            return "typing";
                        case "mousemove":
                        case "mouseenter":
                        case "mouseleave":
                        case "mouseover":
                        case "mouseout":
                            return "mousing";
                        case "scroll":
                            return "scrolling";
                        case "touchstart":
                        case "touchmove":
                        case "touchend":
                        case "touchcancel":
                        case "touchenter":
                        case "touchleave":
                            return "touching";
                        default:
                            return e
                    }
                }
                evtOrigin(e, t) {
                    let i = "unknown";
                    if (e && e instanceof XMLHttpRequest) {
                        const t = this.parent.ee.context(e).params;
                        if (!(t && t.status && t.method && t.host && t.pathname)) return "xhrOriginMissing";
                        i = t.status + " " + t.method + ": " + t.host + t.pathname
                    } else if (e && "string" == typeof e.tagName && (i = e.tagName.toLowerCase(), e.id && (i += "#" + e.id), e.className))
                        for (let t = 0; t < e.classList.length; t++) i += "." + e.classList[t];
                    return "unknown" === i && ("string" == typeof t ? i = t : t === document ? i = "document" : t === window ? i = "window" : t instanceof FileReader && (i = "FileReader")), i
                }
                storeHist(e, t, i) {
                    this.storeSTN(new f("history.pushState", i, i, e, t))
                }#
                v = 0;
                storeResources(e) {
                    e && 0 !== e.length && (e.forEach((e => {
                        if ((0 | e.fetchStart) <= this.#v) return;
                        const {
                            initiatorType: t,
                            fetchStart: i,
                            responseEnd: s,
                            entryType: r
                        } = e, {
                            protocol: n,
                            hostname: a,
                            port: o,
                            pathname: c
                        } = (0, p.D)(e.name), h = new f(t, 0 | i, 0 | s, "".concat(n, "://").concat(a, ":").concat(o).concat(c), r);
                        this.storeSTN(h)
                    })), this.#v = 0 | e[e.length - 1].fetchStart)
                }
                storeErrorAgg(e, t, i, s) {
                    "err" === e && this.storeSTN(new f("error", s.time, s.time, i.message, i.stackHash))
                }
                storeXhrAgg(e, t, i, s) {
                    "xhr" === e && this.storeSTN(new f("Ajax", s.time, s.time + s.duration, "".concat(i.status, " ").concat(i.method, ": ").concat(i.host).concat(i.pathname), "ajax"))
                }
                restoreNode(e, t) {
                    this.nodeCount >= c.jx || (this.nodeCount += t.length, this.trace[e] = this.trace[e] ? t.concat(this.trace[e]) : t)
                }
            }
            var b = i(3762),
                T = i(1687),
                S = i(3311),
                w = i(9119);
            class E extends h.r {
                static featureName = c.TZ;
                constructor(e, t) {
                    super(e, t, c.TZ), this.agentRuntime = (0, o.f)(e), this.agentInfo = (0, n.Vp)(e), this.sentTrace = null, this.harvestTimeSeconds = (0, a.gD)(e, "session_trace.harvestTimeSeconds") || 30, this.entitled = void 0, this.everHarvested = !1, this.harvesting = !1, this.traceStorage = new y(this), this.waitForFlags(["sts", "st"]).then((([e, t]) => this.initialize(e, t)))
                }
                initialize(e, t, i) {
                    return this.entitled ? ? = t, this.blocked || !this.entitled ? (0, T.x3)(this.agentIdentifier, this.featureName) : (this.initialized || (this.initialized = !0, this.ptid = this.agentRuntime.ptid, this.sessionId = this.agentRuntime.session ? .state.value, this.ee.on(d.tS.RESET, (() => {
                        this.blocked || this.abort(1)
                    })), this.ee.on(d.tS.UPDATE, ((e, t) => {
                        this.blocked || (this.mode === d.g.FULL || t.sessionReplayMode !== d.g.FULL && t.sessionTraceMode !== d.g.FULL || this.switchToFull(), (this.sessionId !== t.value || "cross-tab" === e && this.scheduler ? .started && t.sessionTraceMode === d.g.OFF) && this.abort(2))
                    }))), this.agentRuntime.session.isNew || i ? this.mode = e : this.mode = this.agentRuntime.session.state.sessionTraceMode, this.mode === d.g.OFF ? (0, T.x3)(this.agentIdentifier, this.featureName) : (this.timeKeeper ? ? = this.agentRuntime.timeKeeper, this.scheduler = new r.n("browser/blobs", {
                        onFinished: this.onHarvestFinished.bind(this),
                        retryDelay: this.harvestTimeSeconds,
                        getPayload: this.prepareHarvest.bind(this),
                        raw: !0
                    }, this), (0, s.i)("bst", ((...e) => this.traceStorage.storeEvent(...e)), this.featureName, this.ee), (0, s.i)("bstResource", ((...e) => this.traceStorage.storeResources(...e)), this.featureName, this.ee), (0, s.i)("bstHist", ((...e) => this.traceStorage.storeHist(...e)), this.featureName, this.ee), (0, s.i)("bstXhrAgg", ((...e) => this.traceStorage.storeXhrAgg(...e)), this.featureName, this.ee), (0, s.i)("bstApi", ((...e) => this.traceStorage.storeSTN(...e)), this.featureName, this.ee), (0, s.i)("trace-jserror", ((...e) => this.traceStorage.storeErrorAgg(...e)), this.featureName, this.ee), (0, s.i)("pvtAdded", ((...e) => this.traceStorage.processPVT(...e)), this.featureName, this.ee), "undefined" != typeof PerformanceNavigationTiming ? this.traceStorage.storeTiming(u.gm.performance ? .getEntriesByType ? .("navigation")[0]) : this.traceStorage.storeTiming(u.gm.performance ? .timing, !0), this.mode === d.g.FULL ? this.startHarvesting() : (0, s.i)("trace-jserror", (() => {
                        this.mode === d.g.ERROR && this.switchToFull()
                    }), this.featureName, this.ee), this.agentRuntime.session.write({
                        sessionTraceMode: this.mode
                    }), void this.drain()))
                }
                startHarvesting() {
                    this.scheduler.started || this.blocked || (this.scheduler.runHarvest(), this.scheduler.startTimer(this.harvestTimeSeconds))
                }
                prepareHarvest(e = {}) {
                    if (this.traceStorage.prevStoredEvents.clear(), !this.timeKeeper ? .ready) return;
                    if (this.blocked || this.mode !== d.g.FULL || 0 === this.traceStorage.nodeCount) return;
                    if (this.sessionId !== this.agentRuntime.session ? .state.value || this.ptid !== this.agentRuntime.ptid) return this.abort(3);
                    const {
                        stns: t,
                        earliestTimeStamp: i,
                        latestTimeStamp: s
                    } = this.traceStorage.takeSTNs();
                    if (!t) return;
                    e.retry && (this.sentTrace = t);
                    const r = !this.agentRuntime.session.state.traceHarvestStarted;
                    r && this.agentRuntime.session.write({
                        traceHarvestStarted: !0
                    });
                    const n = 1 === this.agentRuntime.session ? .state.sessionReplayMode,
                        a = this.agentInfo ? .jsAttributes ? .["enduser.id"];
                    this.everHarvested = !0;
                    const o = this.agentRuntime.appMetadata ? .agents ? .[0] || {};
                    return {
                        qs: {
                            browser_monitoring_key: this.agentInfo.licenseKey,
                            type: "BrowserSessionChunk",
                            app_id: this.agentInfo.applicationID,
                            protocol_version: "0",
                            timestamp: Math.floor(this.timeKeeper.correctRelativeTimestamp(i)),
                            attributes: (0, b.WL)({ ...o.entityGuid && {
                                    entityGuid: o.entityGuid
                                },
                                harvestId: "".concat(this.agentRuntime.session ? .state.value, "_").concat(this.agentRuntime.ptid, "_").concat(this.agentRuntime.harvestCount),
                                "trace.firstTimestamp": Math.floor(this.timeKeeper.correctRelativeTimestamp(i)),
                                "trace.lastTimestamp": Math.floor(this.timeKeeper.correctRelativeTimestamp(s)),
                                "trace.nodes": t.length,
                                "trace.originTimestamp": this.timeKeeper.correctedOriginTime,
                                agentVersion: this.agentRuntime.version,
                                ...r && {
                                    firstSessionHarvest: r
                                },
                                ...n && {
                                    hasReplay: n
                                },
                                ptid: "".concat(this.ptid),
                                session: "".concat(this.sessionId),
                                ...a && {
                                    "enduser.id": this.obfuscator.obfuscateString(a)
                                },
                                currentUrl: this.obfuscator.obfuscateString((0, w.L)("" + location))
                            }, 5e3).substring(1)
                        },
                        body: (0, S.G)(t, this.obfuscator.obfuscateString.bind(this.obfuscator), "string")
                    }
                }
                onHarvestFinished(e) {
                    e.sent && e.retry && this.sentTrace && (Object.entries(this.sentTrace).forEach((([e, t]) => {
                        this.traceStorage.restoreNode(e, t)
                    })), this.sentTrace = null)
                }
                switchToFull() {
                    if (this.mode === d.g.FULL || !this.entitled || this.blocked) return;
                    const e = this.mode;
                    if (this.mode = d.g.FULL, this.agentRuntime.session.write({
                            sessionTraceMode: this.mode
                        }), e === d.g.OFF || !this.initialized) return this.initialize(this.mode, this.entitled);
                    this.initialized && this.traceStorage.trimSTNs(3e4), this.startHarvesting()
                }
                abort(e) {
                    this.blocked = !0, this.mode = d.g.OFF, this.agentRuntime.session.write({
                        sessionTraceMode: this.mode
                    }), this.scheduler ? .stopTimer()
                }
            }
        },
        1852: (e, t, i) => {
            i.r(t), i.d(t, {
                Aggregate: () => H
            });
            var s = i(9417),
                r = i(1687),
                n = i(9908),
                a = i(3606),
                o = i(1140),
                c = i(6389),
                h = i(8779),
                u = i(860),
                d = i(3969),
                l = i(5942),
                p = i(8771);
            const f = u.K.softNav,
                m = "",
                g = 1,
                v = 2,
                y = 1,
                b = 2,
                T = "in progress",
                S = "finished",
                w = "cancelled";
            var E = i(5519);
            let I = 0;
            class R {
                belType;
                children = [];
                start;
                end;
                callbackEnd = 0;
                callbackDuration = 0;
                nodeId = ++I;
                constructor(e) {
                    if (!e) throw new Error("Interaction is missing core attributes");
                    this.agentIdentifier = e
                }
                addChild(e) {
                    this.children.push(e)
                }
                serialize() {}
            }
            class A extends R {
                constructor(e, t) {
                    super(e), this.belType = b, this.method = t.method, this.status = t.status, this.domain = t.domain, this.path = t.path, this.txSize = t.requestSize, this.rxSize = t.responseSize, this.requestedWith = "fetch" === t.type ? 1 : "", this.spanId = t.spanId, this.traceId = t.traceId, this.spanTimestamp = t.spanTimestamp, this.gql = t.gql, this.start = t.startTime, this.end = t.endTime
                }
                serialize(e) {
                    const t = (0, E.uJ)(this.agentIdentifier),
                        i = [],
                        s = [(0, E.sH)(this.belType), 0, (0, E.sH)(this.start - e), (0, E.sH)(this.end - this.start), (0, E.sH)(this.callbackEnd), (0, E.sH)(this.callbackDuration), t(this.method), (0, E.sH)(this.status), t(this.domain), t(this.path), (0, E.sH)(this.txSize), (0, E.sH)(this.rxSize), this.requestedWith, t(this.nodeId), (0, E.me)(this.spanId, t, !0) + (0, E.me)(this.traceId, t, !0) + (0, E.me)(this.spanTimestamp, E.sH)];
                    let r = [];
                    return "object" == typeof this.gql && (r = (0, E.AQ)(this.gql, t)), this.children.forEach((e => r.push(e.serialize()))), s[1] = (0, E.sH)(r.length), i.push(s), r.length && i.push(r.join(";")), i.join(";")
                }
            }
            var x = i(2733),
                M = i(2555),
                N = i(6154),
                k = i(9566),
                F = i(1863),
                j = i(9119);
            class O extends R {
                id = (0, k.bz)();
                initialPageURL = N.m;
                oldURL = "" + N.gm ? .location;
                newURL = "" + N.gm ? .location;
                customName;
                customAttributes = {};
                customDataByApi = {};
                queueTime;
                appTime;
                newRoute;
                status = T;
                domTimestamp = 0;
                historyTimestamp = 0;
                createdByApi = !1;
                keepOpenUntilEndApi = !1;
                onDone = [];
                cancellationTimer;
                constructor(e, t, i, s) {
                    super(e), this.belType = y, this.trigger = t, this.start = i, this.oldRoute = s, this.eventSubscription = new Map([
                        ["finished", []],
                        ["cancelled", []]
                    ]), this.forceSave = this.forceIgnore = !1, "api" === this.trigger && (this.createdByApi = !0)
                }
                updateDom(e) {
                    this.domTimestamp = e || (0, F.t)()
                }
                updateHistory(e, t) {
                    this.newURL = t || "" + N.gm ? .location, this.historyTimestamp = e || (0, F.t)()
                }
                seenHistoryAndDomChange() {
                    return this.historyTimestamp > 0 && this.domTimestamp > this.historyTimestamp
                }
                on(e, t) {
                    if (!this.eventSubscription.has(e)) throw new Error("Cannot subscribe to non pre-defined events.");
                    if ("function" != typeof t) throw new Error("Must supply function as callback.");
                    this.eventSubscription.get(e).push(t)
                }
                done(e) {
                    return (!this.keepOpenUntilEndApi || void 0 !== e) && (this.onDone.forEach((e => e(this.customDataByApi))), this.forceIgnore ? this.#y() : this.seenHistoryAndDomChange() ? this.#b(e) : this.forceSave ? this.#b(e || performance.now()) : this.#y(), !0)
                }#
                b(e = 0) {
                    if (this.status !== T) return;
                    clearTimeout(this.cancellationTimer), this.end = Math.max(this.domTimestamp, this.historyTimestamp, e), this.customAttributes = { ...(0, M.Vp)(this.agentIdentifier).jsAttributes,
                        ...this.customAttributes
                    }, this.status = S;
                    this.eventSubscription.get("finished").forEach((e => e()))
                }#
                y() {
                    if (this.status !== T) return;
                    clearTimeout(this.cancellationTimer), this.status = w;
                    this.eventSubscription.get("cancelled").forEach((e => e()))
                }
                isActiveDuring(e) {
                    return this.status === T ? this.start <= e : this.status === S && this.start <= e && this.end >= e
                }
                get firstPaint() {}
                get firstContentfulPaint() {}
                get navTiming() {}
                serialize(e) {
                    const t = (0, E.uJ)(this.agentIdentifier),
                        i = [];
                    let s;
                    s = "initialPageLoad" === this.trigger ? m : this.newURL !== this.oldURL ? g : v;
                    const r = [(0, E.sH)(this.belType), 0, (0, E.sH)(this.start - e), (0, E.sH)(this.end - this.start), (0, E.sH)(this.callbackEnd), (0, E.sH)(this.callbackDuration), t(this.trigger), t((0, j.L)(this.initialPageURL, !0)), t((0, j.L)(this.oldURL, !0)), t((0, j.L)(this.newURL, !0)), t(this.customName), s, (0, E.me)(this.queueTime, E.sH, !0) + (0, E.me)(this.appTime, E.sH, !0) + (0, E.me)(this.oldRoute, t, !0) + (0, E.me)(this.newRoute, t, !0) + t(this.id), t(this.nodeId), (0, E.me)(this.firstPaint, E.sH, !0) + (0, E.me)(this.firstContentfulPaint, E.sH)],
                        n = (0, E.AQ)(this.customAttributes || {}, t);
                    return (0, M.Vp)(this.agentIdentifier).atts && n.push("a," + t((0, M.Vp)(this.agentIdentifier).atts)), this.children.forEach((t => n.push(t.serialize(e || this.start)))), r[1] = (0, E.sH)(n.length), i.push(r), n.length && i.push(n.join(";")), this.navTiming ? i.push(this.navTiming) : i.push(""), i.join(";")
                }
            }
            var C = i(5181),
                D = i(5344);
            class L extends O {
                constructor(e) {
                    super(e, "initialPageLoad", 0, null);
                    const t = (0, M.Vp)(e);
                    this.queueTime = t.queueTime, this.appTime = t.applicationTime
                }
                get firstPaint() {
                    return C.J.current.value
                }
                get firstContentfulPaint() {
                    return D.j.current.value
                }
                get navTiming() {
                    if (!x.ss.length) return;
                    let e = ",",
                        t = "b",
                        i = 0;
                    return x.ss.slice(1, 21).forEach((s => {
                        void 0 !== s ? (t += e + (0, E.sH)(s - i), e = ",", i = s) : (t += e + "!", e = "")
                    })), t
                }
            }
            class H extends l.r {
                static featureName = f;
                constructor(e, t, {
                    domObserver: i
                }) {
                    super(e, t, f);
                    const c = (0, s.gD)(e, "soft_navigations.harvestTimeSeconds") || 10;
                    this.interactionsToHarvest = new p.Z, this.domObserver = i, this.initialPageLoadInteraction = new L(e), h.j.subscribe((({
                        attrs: e
                    }) => {
                        const t = e.navigationEntry.loadEventEnd;
                        this.initialPageLoadInteraction.forceSave = !0, this.initialPageLoadInteraction.done(t), this.interactionsToHarvest.add(this.initialPageLoadInteraction), this.initialPageLoadInteraction = null, (0, n.p)(d.xV, ["SoftNav/Interaction/InitialPageLoad/Duration/Ms", Math.round(t)], void 0, u.K.metrics, this.ee)
                    })), this.latestRouteSetByApi = null, this.interactionInProgress = null, this.blocked = !1, this.waitForFlags(["spa"]).then((([t]) => {
                        if (t) {
                            this.drain();
                            const t = new o.n("events", {
                                onFinished: this.onHarvestFinished.bind(this),
                                retryDelay: c,
                                onUnload: () => this.interactionInProgress ? .done()
                            }, {
                                agentIdentifier: e,
                                ee: this.ee
                            });
                            t.harvest.on("events", this.onHarvestStarted.bind(this)), t.startTimer(c, 0)
                        } else this.blocked = !0, (0, r.x3)(this.agentIdentifier, this.featureName)
                    })), (0, a.i)("newUIEvent", (e => this.startUIInteraction(e.type, Math.floor(e.timeStamp), e.target)), this.featureName, this.ee), (0, a.i)("newURL", ((e, t) => this.interactionInProgress ? .updateHistory(e, t)), this.featureName, this.ee), (0, a.i)("newDom", (e => {
                        this.interactionInProgress ? .updateDom(e), this.interactionInProgress ? .seenHistoryAndDomChange() && this.interactionInProgress.done()
                    }), this.featureName, this.ee), this.#T(), (0, a.i)("ajax", this.#S.bind(this), this.featureName, this.ee), (0, a.i)("jserror", this.#w.bind(this), this.featureName, this.ee)
                }
                onHarvestStarted(e) {
                    if (!this.interactionsToHarvest.hasData || this.blocked) return;
                    let t = 0;
                    const i = [];
                    for (const e of this.interactionsToHarvest.buffer) i.push(e.serialize(t)), t || (t = Math.floor(e.start));
                    const s = "bel.7;".concat(i.join(";"));
                    return e.retry ? this.interactionsToHarvest.hold() : this.interactionsToHarvest.clear(), {
                        body: {
                            e: s
                        }
                    }
                }
                onHarvestFinished(e) {
                    e.sent && e.retry && this.interactionsToHarvest.held.hasData ? this.interactionsToHarvest.unhold() : this.interactionsToHarvest.held.clear()
                }
                startUIInteraction(e, t, i) {
                    if (!this.interactionInProgress ? .createdByApi && !1 !== this.interactionInProgress ? .done()) {
                        if (this.interactionInProgress = new O(this.agentIdentifier, e, t, this.latestRouteSetByApi), "click" === e) {
                            const e = function(e) {
                                const t = e.tagName.toLowerCase();
                                if (["a", "button", "input"].includes(t)) return e.title || e.value || e.innerText
                            }(i);
                            e && (this.interactionInProgress.customAttributes.actionText = e)
                        }
                        this.interactionInProgress.cancellationTimer = setTimeout((() => {
                            this.interactionInProgress.done(), (0, n.p)(d.xV, ["SoftNav/Interaction/TimeOut"], void 0, u.K.metrics, this.ee)
                        }), 3e4), this.setClosureHandlers()
                    }
                }
                setClosureHandlers() {
                    this.interactionInProgress.on("finished", (() => {
                        const e = this.interactionInProgress;
                        this.interactionsToHarvest.add(this.interactionInProgress), this.interactionInProgress = null, this.domObserver.disconnect(), (0, n.p)(d.xV, ["SoftNav/Interaction/".concat(e.newURL !== e.oldURL ? "RouteChange" : "Custom", "/Duration/Ms"), Math.round(e.end - e.start)], void 0, u.K.metrics, this.ee)
                    })), this.interactionInProgress.on("cancelled", (() => {
                        this.interactionInProgress = null, this.domObserver.disconnect()
                    }))
                }
                getInteractionFor(e) {
                    if (this.interactionInProgress ? .isActiveDuring(e)) return this.interactionInProgress;
                    let t;
                    for (let i = this.interactionsToHarvest.buffer.length - 1; i >= 0; i--) {
                        const s = this.interactionsToHarvest.buffer[i];
                        if (s.isActiveDuring(e)) {
                            if ("initialPageLoad" !== s.trigger) return s;
                            t = s
                        }
                    }
                    return t || (this.initialPageLoadInteraction ? .isActiveDuring(e) ? this.initialPageLoadInteraction : void 0)
                }#
                S(e) {
                    const t = this.getInteractionFor(e.startTime);

                    function i(e, t, i) {
                        const s = new A(e, t);
                        i.addChild(s)
                    }
                    t ? t.status === S ? i(this.agentIdentifier, e, t) : (t.on("finished", (() => i(this.agentIdentifier, e, t))), t.on("cancelled", (() => (0, n.p)("returnAjax", [e], void 0, u.K.ajax, this.ee)))) : (0, n.p)("returnAjax", [e], void 0, u.K.ajax, this.ee)
                }#
                w(e, t) {
                    const i = this.getInteractionFor(t);
                    i && (e.browserInteractionId = i.id, i.status === S ? (e._softNavFinished = !0, e._softNavAttributes = i.customAttributes) : (i.on("finished", (0, c.J)((() => (0, n.p)("softNavFlush", [i.id, !0, i.customAttributes], void 0, u.K.jserrors, this.ee)))), i.on("cancelled", (0, c.J)((() => (0, n.p)("softNavFlush", [i.id, !1, void 0], void 0, u.K.jserrors, this.ee))))))
                }#
                T() {
                    const e = "api-ixn-",
                        t = this;
                    (0, a.i)(e + "get", (function(e, {
                        waitForEnd: i
                    } = {}) {
                        this.associatedInteraction = t.getInteractionFor(e), this.associatedInteraction || (this.associatedInteraction = t.interactionInProgress = new O(t.agentIdentifier, "api", e, t.latestRouteSetByApi), t.setClosureHandlers()), !0 === i && (this.associatedInteraction.keepOpenUntilEndApi = !0)
                    }), t.featureName, t.ee), (0, a.i)(e + "end", (function(e) {
                        this.associatedInteraction.done(e)
                    }), t.featureName, t.ee), (0, a.i)(e + "save", (function() {
                        this.associatedInteraction.forceSave = !0
                    }), t.featureName, t.ee), (0, a.i)(e + "ignore", (function() {
                        this.associatedInteraction.forceIgnore = !0
                    }), t.featureName, t.ee), (0, a.i)(e + "getContext", (function(e, t) {
                        "function" == typeof t && setTimeout((() => t(this.associatedInteraction.customDataByApi)), 0)
                    }), t.featureName, t.ee), (0, a.i)(e + "onEnd", (function(e, t) {
                        "function" == typeof t && this.associatedInteraction.onDone.push(t)
                    }), t.featureName, t.ee), (0, a.i)(e + "actionText", (function(e, t) {
                        t && (this.associatedInteraction.customAttributes.actionText = t)
                    }), t.featureName, t.ee), (0, a.i)(e + "setName", (function(e, t, i) {
                        t && (this.associatedInteraction.customName = t), i && (this.associatedInteraction.trigger = i)
                    }), t.featureName, t.ee), (0, a.i)(e + "setAttribute", (function(e, t, i) {
                        this.associatedInteraction.customAttributes[t] = i
                    }), t.featureName, t.ee), (0, a.i)(e + "routeName", (function(e, i) {
                        t.latestRouteSetByApi = i, t.interactionInProgress && (t.interactionInProgress.newRoute = i)
                    }), t.featureName, t.ee)
                }
            }
        },
        6526: (e, t, i) => {
            i.d(t, {
                setupAgentSession: () => M
            });
            var s = i(2555),
                r = i(9417),
                n = i(3371),
                a = i(1687),
                o = i(7836),
                c = i(3606),
                h = i(9566),
                u = i(944),
                d = i(3304);
            class l {
                constructor(e, t) {
                    if (!e.onEnd) throw new Error("onEnd handler is required");
                    if (!t) throw new Error("ms duration is required");
                    this.onEnd = e.onEnd, this.initialMs = t, this.startTimestamp = Date.now(), this.timer = this.create(this.onEnd, t)
                }
                create(e, t) {
                    return this.timer && this.clear(), setTimeout((() => e ? e() : this.onEnd()), t || this.initialMs)
                }
                clear() {
                    clearTimeout(this.timer), this.timer = null
                }
                end() {
                    this.clear(), this.onEnd()
                }
                isValid() {
                    return this.initialMs - (Date.now() - this.startTimestamp) > 0
                }
            }
            var p = i(6154),
                f = i(2614),
                m = i(2843),
                g = i(6389);
            class v extends l {
                constructor(e, t) {
                    super(e, t), this.onPause = "function" == typeof e.onPause ? e.onPause : () => {}, this.onRefresh = "function" == typeof e.onRefresh ? e.onRefresh : () => {}, this.onResume = "function" == typeof e.onResume ? e.onResume : () => {}, this.readStorage = e.readStorage, this.remainingMs = void 0, e.refreshEvents || (e.refreshEvents = ["click", "keydown", "scroll"]);
                    try {
                        this.abortController = new AbortController
                    } catch (e) {}
                    if (p.RI && e.ee) {
                        if (e.ee) {
                            this.ee = e.ee;
                            const t = (0, g.s)(this.refresh.bind(this), 500, {
                                leading: !0
                            });
                            this.refreshHandler = i => {
                                e.refreshEvents.includes(i ? .[0] ? .type) && t()
                            }, e.ee.on("fn-end", this.refreshHandler)
                        }(0, m.u)((e => {
                            "hidden" === e ? this.pause() : this.resume()
                        }), !1, !1, this.abortController ? .signal)
                    }
                }
                abort() {
                    this.clear(), this.abortController ? .abort(), this.refreshHandler && (this.ee.removeEventListener("fn-end", this.refreshHandler), this.refreshHandler = this.ee = null)
                }
                pause() {
                    this.onPause(), clearTimeout(this.timer), this.remainingMs = this.initialMs - (Date.now() - this.startTimestamp)
                }
                resume() {
                    try {
                        const t = this.readStorage(),
                            i = "string" == typeof t ? JSON.parse(t) : t;
                        e(i.expiresAt) || e(i.inactiveAt) ? this.end() : (this.refresh(), this.onResume())
                    } catch (e) {
                        this.end()
                    }

                    function e(e) {
                        return Date.now() > e
                    }
                }
                refresh(e, t) {
                    this.clear(), this.timer = this.create(e, t), this.startTimestamp = Date.now(), this.remainingMs = void 0, this.onRefresh()
                }
            }
            var y = i(8139),
                b = i(8122),
                T = i(9908),
                S = i(3969),
                w = i(860),
                E = i(3878);
            const I = {
                value: "",
                inactiveAt: 0,
                expiresAt: 0,
                updatedAt: Date.now(),
                sessionReplayMode: f.g.OFF,
                sessionReplaySentFirstChunk: !1,
                sessionTraceMode: f.g.OFF,
                traceHarvestStarted: !1,
                serverTimeDiff: null,
                custom: {}
            };
            class R {
                constructor(e) {
                    const {
                        agentIdentifier: t,
                        key: i,
                        storage: s
                    } = e;
                    if (!t || !i || !s) throw new Error("Missing required field(s):".concat(t ? "" : " agentID").concat(i ? "" : " key").concat(s ? "" : " storage"));
                    this.agentIdentifier = t, this.storage = s, this.state = {}, this.key = i, this.ee = o.ee.get(t), (0, y.u)(this.ee), this.setup(e), p.RI && (0, E.sp)("storage", (e => {
                        if (e.key === this.lookupKey) {
                            const t = "string" == typeof e.newValue ? JSON.parse(e.newValue) : e.newValue;
                            this.sync(t), this.ee.emit(f.tS.UPDATE, [f.iL.CROSS_TAB, this.state])
                        }
                    }))
                }
                setup({
                    value: e = (0, h.LA)(16),
                    expiresMs: t = f.wk,
                    inactiveMs: i = f.BB
                }) {
                    const s = {
                        serverTimeDiff: this.state.serverTimeDiff || I.serverTimeDiff
                    };
                    this.state = {}, this.sync({ ...I,
                        ...s
                    }), this.state.value = e, this.expiresMs = t, this.inactiveMs = i;
                    const r = this.read();
                    t ? (this.state.expiresAt = r ? .expiresAt || this.getFutureTimestamp(t), this.expiresTimer = new l({
                        onEnd: () => {
                            this.collectSM("expired"), this.collectSM("duration"), this.reset()
                        }
                    }, this.state.expiresAt - Date.now())) : this.state.expiresAt = 1 / 0, i ? (this.state.inactiveAt = r ? .inactiveAt || this.getFutureTimestamp(i), this.inactiveTimer = new v({
                        onEnd: () => {
                            this.collectSM("inactive"), this.collectSM("duration"), this.reset()
                        },
                        onRefresh: this.refresh.bind(this),
                        onResume: () => {
                            this.ee.emit(f.tS.RESUME)
                        },
                        onPause: () => {
                            this.initialized && this.ee.emit(f.tS.PAUSE), this.write((0, b.a)(this.state, I))
                        },
                        ee: this.ee,
                        refreshEvents: ["click", "keydown", "scroll"],
                        readStorage: () => this.storage.get(this.lookupKey)
                    }, this.state.inactiveAt - Date.now())) : this.state.inactiveAt = 1 / 0, this.isNew || = !Object.keys(r).length, this.isNew ? this.write((0, b.a)(this.state, I), !0) : this.sync(r), this.initialized = !0, this.ee.emit(f.tS.STARTED, [this.isNew])
                }
                get lookupKey() {
                    return "".concat(f.H3, "_").concat(this.key)
                }
                sync(e) {
                    Object.assign(this.state, e)
                }
                read() {
                    try {
                        const e = this.storage.get(this.lookupKey);
                        if (!e) return {};
                        const t = "string" == typeof e ? JSON.parse(e) : e;
                        return this.isInvalid(t) ? {} : this.isExpired(t.expiresAt) ? (this.collectSM("expired"), this.collectSM("duration", t, !0), this.reset()) : this.isExpired(t.inactiveAt) ? (this.collectSM("inactive"), this.collectSM("duration", t, !0), this.reset()) : t
                    } catch (e) {
                        return (0, u.R)(10, e), {}
                    }
                }
                write(e) {
                    try {
                        if (!e || "object" != typeof e) return;
                        return e.updatedAt = Date.now(), this.sync(e), this.storage.set(this.lookupKey, (0, d.A)(this.state)), this.ee.emit(f.tS.UPDATE, [f.iL.SAME_TAB, this.state]), e
                    } catch (e) {
                        return (0, u.R)(11, e), null
                    }
                }
                reset() {
                    try {
                        return this.initialized && this.ee.emit(f.tS.RESET), this.storage.remove(this.lookupKey), this.inactiveTimer ? .abort ? .(), this.expiresTimer ? .clear ? .(), delete this.isNew, this.setup({
                            agentIdentifier: this.agentIdentifier,
                            key: this.key,
                            storage: this.storage,
                            expiresMs: this.expiresMs,
                            inactiveMs: this.inactiveMs
                        }), this.read()
                    } catch (e) {
                        return {}
                    }
                }
                refresh() {
                    const e = this.read();
                    this.write({ ...e,
                        inactiveAt: this.getFutureTimestamp(this.inactiveMs)
                    })
                }
                isExpired(e) {
                    return Date.now() > e
                }
                isInvalid(e) {
                    return !Object.keys(I).every((t => Object.keys(e).includes(t)))
                }
                collectSM(e, t, i) {
                    let s, r;
                    "duration" === e && (s = this.getDuration(t, i), r = "Session/Duration/Ms"), "expired" === e && (r = "Session/Expired/Seen"), "inactive" === e && (r = "Session/Inactive/Seen"), r && (0, T.p)(S.xV, [r, s], void 0, w.K.metrics, this.ee)
                }
                getDuration(e = this.state, t) {
                    const i = e.expiresAt - this.expiresMs;
                    return (t ? Date.now() : e.updatedAt) - i
                }
                getFutureTimestamp(e) {
                    return Date.now() + e
                }
                syncCustomAttribute(e, t) {
                    if (p.RI)
                        if (null === t) {
                            const t = this.read();
                            t.custom && (delete t.custom[e], this.write({ ...t
                            }))
                        } else {
                            const i = this.read();
                            this.custom = { ...i ? .custom || {},
                                [e] : t
                            }, this.write({ ...i,
                                custom: this.custom
                            })
                        }
                }
            }
            class A {
                get(e) {
                    try {
                        return localStorage.getItem(e) || void 0
                    } catch (e) {
                        return ""
                    }
                }
                set(e, t) {
                    try {
                        return null == t ? this.remove(e) : localStorage.setItem(e, t)
                    } catch (e) {}
                }
                remove(e) {
                    try {
                        localStorage.removeItem(e)
                    } catch (e) {}
                }
            }
            let x = 0;

            function M(e) {
                const t = (0, n.f)(e);
                if (x++) return t.session;
                const i = (0, r.D0)(e).session;
                t.session = new R({
                    agentIdentifier: e,
                    key: f.uh,
                    storage: new A,
                    expiresMs: i ? .expiresMs,
                    inactiveMs: i ? .inactiveMs
                });
                const h = t.session.state.custom,
                    u = (0, s.Vp)(e);
                h && (u.jsAttributes = { ...u.jsAttributes,
                    ...h
                });
                const d = o.ee.get(e);
                return (0, c.i)("api-setCustomAttribute", ((e, i, s) => {
                    t.session.syncCustomAttribute(i, s)
                }), "session", d), (0, c.i)("api-setUserId", ((e, i, s) => {
                    t.session.syncCustomAttribute(i, s)
                }), "session", d), (0, a.Ze)(e, "session"), t.session
            }
        },
        5942: (e, t, i) => {
            i.d(t, {
                r: () => f
            });
            var s = i(4234),
                r = i(2555),
                n = i(3371),
                a = i(425),
                o = i(384),
                c = i(1687),
                h = i(5284),
                u = i(9417),
                d = i(4284),
                l = i(944);
            class p {#
                E;
                constructor(e) {
                    this.#E = p.getRuleValidationCache(e), p.logObfuscationRuleErrors(this.#E)
                }
                get ruleValidationCache() {
                    return this.#E
                }
                obfuscateString(e) {
                    return "string" != typeof e || 0 === e.trim().length ? e : this.#E.filter((e => e.isValid)).reduce(((e, t) => {
                        const {
                            rule: i
                        } = t;
                        return e.replace(i.regex, i.replacement || "*")
                    }), e)
                }
                static getRuleValidationCache(e) {
                    let t = (0, u.gD)(e, "obfuscate") || [];
                    return (0, d.p)() && t.push({
                        regex: /^file:\/\/(.*)/,
                        replacement: atob("ZmlsZTovL09CRlVTQ0FURUQ=")
                    }), t.map((e => p.validateObfuscationRule(e)))
                }
                static validateObfuscationRule(e) {
                    const t = Boolean(void 0 === e.regex),
                        i = Boolean(void 0 !== e.regex && "string" != typeof e.regex && !(e.regex instanceof RegExp)),
                        s = Boolean(e.replacement && "string" != typeof e.replacement);
                    return {
                        rule: e,
                        isValid: !t && !i && !s,
                        errors: {
                            regexMissingDetected: t,
                            invalidRegexDetected: i,
                            invalidReplacementDetected: s
                        }
                    }
                }
                static logObfuscationRuleErrors(e) {
                    for (const t of e) {
                        const {
                            rule: e,
                            isValid: i,
                            errors: s
                        } = t;
                        i || (s.regexMissingDetected ? (0, l.R)(12, e) : s.invalidRegexDetected && (0, l.R)(13, e), s.invalidReplacementDetected && (0, l.R)(14, e))
                    }
                }
            }
            class f extends s.W {
                constructor(...e) {
                    super(...e), this.checkConfiguration(), this.obfuscator = (0, n.f)(this.agentIdentifier).obfuscator
                }
                waitForFlags(e = []) {
                    return new Promise(((t, i) => {
                        function s(t) {
                            return e.map((e => t[e] ? t[e] : 0))
                        }
                        h.B[this.agentIdentifier] ? t(s(h.B[this.agentIdentifier])) : this.ee.on("rumresp", ((e = {}) => {
                            t(s(e))
                        }))
                    })).catch((e => {
                        this.ee.emit("internal-error", [e]), this.blocked = !0, (0, c.x3)(this.agentIdentifier, this.featureName)
                    }))
                }
                drain() {
                    (0, c.Ze)(this.agentIdentifier, this.featureName), this.drained = !0
                }
                checkConfiguration() {
                    if (!(0, r.fn)(this.agentIdentifier)) {
                        const e = (0, o.pV)();
                        let t = { ...e.info ? .jsAttributes
                        };
                        try {
                            t = { ...t,
                                ...(0, r.Vp)(this.agentIdentifier) ? .jsAttributes
                            }
                        } catch (e) {}(0, a.j)({
                            agentIdentifier: this.agentIdentifier
                        }, { ...e,
                            info: { ...e.info,
                                jsAttributes: t
                            },
                            runtime: (0, n.f)(this.agentIdentifier)
                        })
                    }
                    const e = (0, n.f)(this.agentIdentifier);
                    e.obfuscator || (e.obfuscator = new p(this.agentIdentifier))
                }
            }
        },
        8771: (e, t, i) => {
            i.d(t, {
                Z: () => n
            });
            var s = i(3304),
                r = i(7699);
            class n {#
                I = [];#
                R = 0;#
                A;
                constructor(e = r.I) {
                    this.maxPayloadSize = e
                }
                get buffer() {
                    return this.#I
                }
                get bytes() {
                    return this.#R
                }
                get held() {
                    return this.#A || (this.#A = new n(this.maxPayloadSize)), this.#A
                }
                get hasData() {
                    return this.buffer.length > 0 && this.bytes > 0
                }
                add(e) {
                    const t = (0, s.A)(e).length;
                    return this.canMerge(t) ? (this.#I.push(e), this.#R += t, this) : this
                }
                clear() {
                    return this.#R = 0, this.#I = [], this
                }
                hold() {
                    return this.held.merge(this), this.clear(), this
                }
                unhold() {
                    return this.merge(this.held, !0), this.held.clear(), this
                }
                merge(e, t = !1) {
                    return this.canMerge(e.bytes) ? (this.#I = t ? [...e.buffer, ...this.#I] : [...this.#I, ...e.buffer], this.#R += e.#R, this) : this
                }
                canMerge(e) {
                    return this.bytes + (e || 1 / 0) < this.maxPayloadSize
                }
            }
        },
        6103: (e, t, i) => {
            i.d(t, {
                lazyFeatureLoader: () => r
            });
            var s = i(860);

            function r(e, t) {
                if ("aggregate" === t) switch (e) {
                    case s.K.ajax:
                        return i.e(891).then(i.bind(i, 6674));
                    case s.K.jserrors:
                        return i.e(891).then(i.bind(i, 2823));
                    case s.K.genericEvents:
                        return i.e(891).then(i.bind(i, 8019));
                    case s.K.logging:
                        return i.e(891).then(i.bind(i, 5288));
                    case s.K.metrics:
                        return i.e(891).then(i.bind(i, 8351));
                    case s.K.pageViewEvent:
                        return i.e(891).then(i.bind(i, 1983));
                    case s.K.pageViewTiming:
                        return i.e(891).then(i.bind(i, 5999));
                    case s.K.sessionReplay:
                        return i.e(891).then(i.bind(i, 6167));
                    case s.K.sessionTrace:
                        return i.e(891).then(i.bind(i, 575));
                    case s.K.spa:
                        return Promise.resolve().then((function() {
                            var e = new Error("Cannot find module '../spa/aggregate'");
                            throw e.code = "MODULE_NOT_FOUND", e
                        }));
                    case s.K.softNav:
                        return i.e(891).then(i.bind(i, 1852));
                    default:
                        throw new Error("Attempted to load unsupported agent feature: ".concat(e, " ").concat(t))
                }
            }
        },
        8778: (e, t, i) => {
            i.r(t), i.d(t, {
                setAPI: () => d
            });
            var s = i(860),
                r = i(3371),
                n = i(7836),
                a = i(9908),
                o = i(3606),
                c = i(6389),
                h = i(3969),
                u = i(6154);

            function d(e) {
                var t = n.ee.get(e),
                    i = {
                        finished: (0, c.J)((function(e, i) {
                            var r = i ? i - u.WN : e;
                            (0, a.p)(h.XG, ["finished", {
                                time: r
                            }], void 0, s.K.metrics, t), d(e, {
                                name: "finished",
                                start: r + u.WN,
                                origin: "nr"
                            }), (0, a.p)("api-addPageAction", [r, "finished"], void 0, s.K.genericEvents, t)
                        })),
                        setErrorHandler: function(t, i) {
                            (0, r.f)(e).onerror = i
                        },
                        addToTrace: d,
                        addRelease: function(t, i, s) {
                            if (++l > 10) return;
                            (0, r.f)(e).releaseIds[i.slice(-200)] = ("" + s).slice(-200)
                        }
                    };

                function d(e, i) {
                    if (i && "object" == typeof i && i.name && i.start) {
                        var r = {
                            n: i.name,
                            s: i.start - u.WN,
                            e: (i.end || i.start) - u.WN,
                            o: i.origin || "",
                            t: "api"
                        };
                        (0, a.p)("bstApi", [r], void 0, s.K.sessionTrace, t)
                    }
                }
                Object.entries(i).forEach((([e, i]) => (0, o.i)("api-" + e, i, "api", t)));
                var l = 0
            }
        },
        7226: (e, t, i) => {
            i.d(t, {
                Ck: () => le,
                IN: () => N,
                fK: () => ce,
                lt: () => Te,
                rH: () => ne,
                zB: () => k
            });
            var s, r, n = function() {
                    var e = self.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
                    if (e && e.responseStart > 0 && e.responseStart < performance.now()) return e
                },
                a = function(e) {
                    if ("loading" === document.readyState) return "loading";
                    var t = n();
                    if (t) {
                        if (e < t.domInteractive) return "loading";
                        if (0 === t.domContentLoadedEventStart || e < t.domContentLoadedEventStart) return "dom-interactive";
                        if (0 === t.domComplete || e < t.domComplete) return "dom-content-loaded"
                    }
                    return "complete"
                },
                o = function(e) {
                    var t = e.nodeName;
                    return 1 === e.nodeType ? t.toLowerCase() : t.toUpperCase().replace(/^#/, "")
                },
                c = function(e, t) {
                    var i = "";
                    try {
                        for (; e && 9 !== e.nodeType;) {
                            var s = e,
                                r = s.id ? "#" + s.id : o(s) + (s.classList && s.classList.value && s.classList.value.trim() && s.classList.value.trim().length ? "." + s.classList.value.trim().replace(/\s+/g, ".") : "");
                            if (i.length + r.length > (t || 100) - 1) return i || r;
                            if (i = i ? r + ">" + i : r, s.id) break;
                            e = s.parentNode
                        }
                    } catch (e) {}
                    return i
                },
                h = -1,
                u = function() {
                    return h
                },
                d = function(e) {
                    addEventListener("pageshow", (function(t) {
                        t.persisted && (h = t.timeStamp, e(t))
                    }), !0)
                },
                l = function() {
                    var e = n();
                    return e && e.activationStart || 0
                },
                p = function(e, t) {
                    var i = n(),
                        s = "navigate";
                    return u() >= 0 ? s = "back-forward-cache" : i && (document.prerendering || l() > 0 ? s = "prerender" : document.wasDiscarded ? s = "restore" : i.type && (s = i.type.replace(/_/g, "-"))), {
                        name: e,
                        value: void 0 === t ? -1 : t,
                        rating: "good",
                        delta: 0,
                        entries: [],
                        id: "v4-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12),
                        navigationType: s
                    }
                },
                f = function(e, t, i) {
                    try {
                        if (PerformanceObserver.supportedEntryTypes.includes(e)) {
                            var s = new PerformanceObserver((function(e) {
                                Promise.resolve().then((function() {
                                    t(e.getEntries())
                                }))
                            }));
                            return s.observe(Object.assign({
                                type: e,
                                buffered: !0
                            }, i || {})), s
                        }
                    } catch (e) {}
                },
                m = function(e, t, i, s) {
                    var r, n;
                    return function(a) {
                        t.value >= 0 && (a || s) && ((n = t.value - (r || 0)) || void 0 === r) && (r = t.value, t.delta = n, t.rating = function(e, t) {
                            return e > t[1] ? "poor" : e > t[0] ? "needs-improvement" : "good"
                        }(t.value, i), e(t))
                    }
                },
                g = function(e) {
                    requestAnimationFrame((function() {
                        return requestAnimationFrame((function() {
                            return e()
                        }))
                    }))
                },
                v = function(e) {
                    document.addEventListener("visibilitychange", (function() {
                        "hidden" === document.visibilityState && e()
                    }))
                },
                y = function(e) {
                    var t = !1;
                    return function() {
                        t || (e(), t = !0)
                    }
                },
                b = -1,
                T = function() {
                    return "hidden" !== document.visibilityState || document.prerendering ? 1 / 0 : 0
                },
                S = function(e) {
                    "hidden" === document.visibilityState && b > -1 && (b = "visibilitychange" === e.type ? e.timeStamp : 0, E())
                },
                w = function() {
                    addEventListener("visibilitychange", S, !0), addEventListener("prerenderingchange", S, !0)
                },
                E = function() {
                    removeEventListener("visibilitychange", S, !0), removeEventListener("prerenderingchange", S, !0)
                },
                I = function() {
                    return b < 0 && (b = T(), w(), d((function() {
                        setTimeout((function() {
                            b = T(), w()
                        }), 0)
                    }))), {
                        get firstHiddenTime() {
                            return b
                        }
                    }
                },
                R = function(e) {
                    document.prerendering ? addEventListener("prerenderingchange", (function() {
                        return e()
                    }), !0) : e()
                },
                A = [1800, 3e3],
                x = function(e, t) {
                    t = t || {}, R((function() {
                        var i, s = I(),
                            r = p("FCP"),
                            n = f("paint", (function(e) {
                                e.forEach((function(e) {
                                    "first-contentful-paint" === e.name && (n.disconnect(), e.startTime < s.firstHiddenTime && (r.value = Math.max(e.startTime - l(), 0), r.entries.push(e), i(!0)))
                                }))
                            }));
                        n && (i = m(e, r, A, t.reportAllChanges), d((function(s) {
                            r = p("FCP"), i = m(e, r, A, t.reportAllChanges), g((function() {
                                r.value = performance.now() - s.timeStamp, i(!0)
                            }))
                        })))
                    }))
                },
                M = [.1, .25],
                N = function(e, t) {
                    ! function(e, t) {
                        t = t || {}, x(y((function() {
                            var i, s = p("CLS", 0),
                                r = 0,
                                n = [],
                                a = function(e) {
                                    e.forEach((function(e) {
                                        if (!e.hadRecentInput) {
                                            var t = n[0],
                                                i = n[n.length - 1];
                                            r && e.startTime - i.startTime < 1e3 && e.startTime - t.startTime < 5e3 ? (r += e.value, n.push(e)) : (r = e.value, n = [e])
                                        }
                                    })), r > s.value && (s.value = r, s.entries = n, i())
                                },
                                o = f("layout-shift", a);
                            o && (i = m(e, s, M, t.reportAllChanges), v((function() {
                                a(o.takeRecords()), i(!0)
                            })), d((function() {
                                r = 0, s = p("CLS", 0), i = m(e, s, M, t.reportAllChanges), g((function() {
                                    return i()
                                }))
                            })), setTimeout(i, 0))
                        })))
                    }((function(t) {
                        var i = function(e) {
                            var t, i = {};
                            if (e.entries.length) {
                                var s = e.entries.reduce((function(e, t) {
                                    return e && e.value > t.value ? e : t
                                }));
                                if (s && s.sources && s.sources.length) {
                                    var r = (t = s.sources).find((function(e) {
                                        return e.node && 1 === e.node.nodeType
                                    })) || t[0];
                                    r && (i = {
                                        largestShiftTarget: c(r.node),
                                        largestShiftTime: s.startTime,
                                        largestShiftValue: s.value,
                                        largestShiftSource: r,
                                        largestShiftEntry: s,
                                        loadState: a(s.startTime)
                                    })
                                }
                            }
                            return Object.assign(e, {
                                attribution: i
                            })
                        }(t);
                        e(i)
                    }), t)
                },
                k = function(e, t) {
                    x((function(t) {
                        var i = function(e) {
                            var t = {
                                timeToFirstByte: 0,
                                firstByteToFCP: e.value,
                                loadState: a(u())
                            };
                            if (e.entries.length) {
                                var i = n(),
                                    s = e.entries[e.entries.length - 1];
                                if (i) {
                                    var r = i.activationStart || 0,
                                        o = Math.max(0, i.responseStart - r);
                                    t = {
                                        timeToFirstByte: o,
                                        firstByteToFCP: e.value - o,
                                        loadState: a(e.entries[0].startTime),
                                        navigationEntry: i,
                                        fcpEntry: s
                                    }
                                }
                            }
                            return Object.assign(e, {
                                attribution: t
                            })
                        }(t);
                        e(i)
                    }), t)
                },
                F = 0,
                j = 1 / 0,
                O = 0,
                C = function(e) {
                    e.forEach((function(e) {
                        e.interactionId && (j = Math.min(j, e.interactionId), O = Math.max(O, e.interactionId), F = O ? (O - j) / 7 + 1 : 0)
                    }))
                },
                D = function() {
                    return s ? F : performance.interactionCount || 0
                },
                L = function() {
                    "interactionCount" in performance || s || (s = f("event", C, {
                        type: "event",
                        buffered: !0,
                        durationThreshold: 0
                    }))
                },
                H = [],
                P = new Map,
                _ = 0,
                U = [],
                B = function(e) {
                    if (U.forEach((function(t) {
                            return t(e)
                        })), e.interactionId || "first-input" === e.entryType) {
                        var t = H[H.length - 1],
                            i = P.get(e.interactionId);
                        if (i || H.length < 10 || e.duration > t.latency) {
                            if (i) e.duration > i.latency ? (i.entries = [e], i.latency = e.duration) : e.duration === i.latency && e.startTime === i.entries[0].startTime && i.entries.push(e);
                            else {
                                var s = {
                                    id: e.interactionId,
                                    latency: e.duration,
                                    entries: [e]
                                };
                                P.set(s.id, s), H.push(s)
                            }
                            H.sort((function(e, t) {
                                return t.latency - e.latency
                            })), H.length > 10 && H.splice(10).forEach((function(e) {
                                return P.delete(e.id)
                            }))
                        }
                    }
                },
                K = function(e) {
                    var t = self.requestIdleCallback || self.setTimeout,
                        i = -1;
                    return e = y(e), "hidden" === document.visibilityState ? e() : (i = t(e), v(e)), i
                },
                V = [200, 500],
                q = function(e, t) {
                    "PerformanceEventTiming" in self && "interactionId" in PerformanceEventTiming.prototype && (t = t || {}, R((function() {
                        var i;
                        L();
                        var s, r = p("INP"),
                            n = function(e) {
                                K((function() {
                                    e.forEach(B);
                                    var t = function() {
                                        var e = Math.min(H.length - 1, Math.floor((D() - _) / 50));
                                        return H[e]
                                    }();
                                    t && t.latency !== r.value && (r.value = t.latency, r.entries = t.entries, s())
                                }))
                            },
                            a = f("event", n, {
                                durationThreshold: null !== (i = t.durationThreshold) && void 0 !== i ? i : 40
                            });
                        s = m(e, r, V, t.reportAllChanges), a && (a.observe({
                            type: "first-input",
                            buffered: !0
                        }), v((function() {
                            n(a.takeRecords()), s(!0)
                        })), d((function() {
                            _ = D(), H.length = 0, P.clear(), r = p("INP"), s = m(e, r, V, t.reportAllChanges)
                        })))
                    })))
                },
                z = [],
                G = [],
                W = 0,
                J = new WeakMap,
                Z = new Map,
                X = -1,
                Q = function(e) {
                    z = z.concat(e), Y()
                },
                Y = function() {
                    X < 0 && (X = K(ee))
                },
                ee = function() {
                    Z.size > 10 && Z.forEach((function(e, t) {
                        P.has(t) || Z.delete(t)
                    }));
                    var e = H.map((function(e) {
                            return J.get(e.entries[0])
                        })),
                        t = G.length - 50;
                    G = G.filter((function(i, s) {
                        return s >= t || e.includes(i)
                    }));
                    for (var i = new Set, s = 0; s < G.length; s++) {
                        var r = G[s];
                        re(r.startTime, r.processingEnd).forEach((function(e) {
                            i.add(e)
                        }))
                    }
                    var n = z.length - 1 - 50;
                    z = z.filter((function(e, t) {
                        return e.startTime > W && t > n || i.has(e)
                    })), X = -1
                };
            U.push((function(e) {
                e.interactionId && e.target && !Z.has(e.interactionId) && Z.set(e.interactionId, e.target)
            }), (function(e) {
                var t, i = e.startTime + e.duration;
                W = Math.max(W, e.processingEnd);
                for (var s = G.length - 1; s >= 0; s--) {
                    var r = G[s];
                    if (Math.abs(i - r.renderTime) <= 8) {
                        (t = r).startTime = Math.min(e.startTime, t.startTime), t.processingStart = Math.min(e.processingStart, t.processingStart), t.processingEnd = Math.max(e.processingEnd, t.processingEnd), t.entries.push(e);
                        break
                    }
                }
                t || (t = {
                    startTime: e.startTime,
                    processingStart: e.processingStart,
                    processingEnd: e.processingEnd,
                    renderTime: i,
                    entries: [e]
                }, G.push(t)), (e.interactionId || "first-input" === e.entryType) && J.set(e, t), Y()
            }));
            var te, $, ie, se, re = function(e, t) {
                    for (var i, s = [], r = 0; i = z[r]; r++)
                        if (!(i.startTime + i.duration < e)) {
                            if (i.startTime > t) break;
                            s.push(i)
                        }
                    return s
                },
                ne = function(e, t) {
                    r || (r = f("long-animation-frame", Q)), q((function(t) {
                        var i = function(e) {
                            var t = e.entries[0],
                                i = J.get(t),
                                s = t.processingStart,
                                r = i.processingEnd,
                                n = i.entries.sort((function(e, t) {
                                    return e.processingStart - t.processingStart
                                })),
                                o = re(t.startTime, r),
                                h = e.entries.find((function(e) {
                                    return e.target
                                })),
                                u = h && h.target || Z.get(t.interactionId),
                                d = [t.startTime + t.duration, r].concat(o.map((function(e) {
                                    return e.startTime + e.duration
                                }))),
                                l = Math.max.apply(Math, d),
                                p = {
                                    interactionTarget: c(u),
                                    interactionTargetElement: u,
                                    interactionType: t.name.startsWith("key") ? "keyboard" : "pointer",
                                    interactionTime: t.startTime,
                                    nextPaintTime: l,
                                    processedEventEntries: n,
                                    longAnimationFrameEntries: o,
                                    inputDelay: s - t.startTime,
                                    processingDuration: r - s,
                                    presentationDelay: Math.max(l - r, 0),
                                    loadState: a(t.startTime)
                                };
                            return Object.assign(e, {
                                attribution: p
                            })
                        }(t);
                        e(i)
                    }), t)
                },
                ae = [2500, 4e3],
                oe = {},
                ce = function(e, t) {
                    ! function(e, t) {
                        t = t || {}, R((function() {
                            var i, s = I(),
                                r = p("LCP"),
                                n = function(e) {
                                    t.reportAllChanges || (e = e.slice(-1)), e.forEach((function(e) {
                                        e.startTime < s.firstHiddenTime && (r.value = Math.max(e.startTime - l(), 0), r.entries = [e], i())
                                    }))
                                },
                                a = f("largest-contentful-paint", n);
                            if (a) {
                                i = m(e, r, ae, t.reportAllChanges);
                                var o = y((function() {
                                    oe[r.id] || (n(a.takeRecords()), a.disconnect(), oe[r.id] = !0, i(!0))
                                }));
                                ["keydown", "click"].forEach((function(e) {
                                    addEventListener(e, (function() {
                                        return K(o)
                                    }), !0)
                                })), v(o), d((function(s) {
                                    r = p("LCP"), i = m(e, r, ae, t.reportAllChanges), g((function() {
                                        r.value = performance.now() - s.timeStamp, oe[r.id] = !0, i(!0)
                                    }))
                                }))
                            }
                        }))
                    }((function(t) {
                        var i = function(e) {
                            var t = {
                                timeToFirstByte: 0,
                                resourceLoadDelay: 0,
                                resourceLoadDuration: 0,
                                elementRenderDelay: e.value
                            };
                            if (e.entries.length) {
                                var i = n();
                                if (i) {
                                    var s = i.activationStart || 0,
                                        r = e.entries[e.entries.length - 1],
                                        a = r.url && performance.getEntriesByType("resource").filter((function(e) {
                                            return e.name === r.url
                                        }))[0],
                                        o = Math.max(0, i.responseStart - s),
                                        h = Math.max(o, a ? (a.requestStart || a.startTime) - s : 0),
                                        u = Math.max(h, a ? a.responseEnd - s : 0),
                                        d = Math.max(u, r.startTime - s);
                                    t = {
                                        element: c(r.element),
                                        timeToFirstByte: o,
                                        resourceLoadDelay: h - o,
                                        resourceLoadDuration: u - h,
                                        elementRenderDelay: d - u,
                                        navigationEntry: i,
                                        lcpEntry: r
                                    }, r.url && (t.url = r.url), a && (t.lcpResourceEntry = a)
                                }
                            }
                            return Object.assign(e, {
                                attribution: t
                            })
                        }(t);
                        e(i)
                    }), t)
                },
                he = [800, 1800],
                ue = function e(t) {
                    document.prerendering ? R((function() {
                        return e(t)
                    })) : "complete" !== document.readyState ? addEventListener("load", (function() {
                        return e(t)
                    }), !0) : setTimeout(t, 0)
                },
                de = function(e, t) {
                    t = t || {};
                    var i = p("TTFB"),
                        s = m(e, i, he, t.reportAllChanges);
                    ue((function() {
                        var r = n();
                        r && (i.value = Math.max(r.responseStart - l(), 0), i.entries = [r], s(!0), d((function() {
                            i = p("TTFB", 0), (s = m(e, i, he, t.reportAllChanges))(!0)
                        })))
                    }))
                },
                le = function(e, t) {
                    de((function(t) {
                        var i = function(e) {
                            var t = {
                                waitingDuration: 0,
                                cacheDuration: 0,
                                dnsDuration: 0,
                                connectionDuration: 0,
                                requestDuration: 0
                            };
                            if (e.entries.length) {
                                var i = e.entries[0],
                                    s = i.activationStart || 0,
                                    r = Math.max((i.workerStart || i.fetchStart) - s, 0),
                                    n = Math.max(i.domainLookupStart - s, 0),
                                    a = Math.max(i.connectStart - s, 0),
                                    o = Math.max(i.connectEnd - s, 0);
                                t = {
                                    waitingDuration: r,
                                    cacheDuration: n - r,
                                    dnsDuration: a - n,
                                    connectionDuration: o - a,
                                    requestDuration: e.value - o,
                                    navigationEntry: i
                                }
                            }
                            return Object.assign(e, {
                                attribution: t
                            })
                        }(t);
                        e(i)
                    }), t)
                },
                pe = {
                    passive: !0,
                    capture: !0
                },
                fe = new Date,
                me = function(e, t) {
                    te || (te = t, $ = e, ie = new Date, ye(removeEventListener), ge())
                },
                ge = function() {
                    if ($ >= 0 && $ < ie - fe) {
                        var e = {
                            entryType: "first-input",
                            name: te.type,
                            target: te.target,
                            cancelable: te.cancelable,
                            startTime: te.timeStamp,
                            processingStart: te.timeStamp + $
                        };
                        se.forEach((function(t) {
                            t(e)
                        })), se = []
                    }
                },
                ve = function(e) {
                    if (e.cancelable) {
                        var t = (e.timeStamp > 1e12 ? new Date : performance.now()) - e.timeStamp;
                        "pointerdown" == e.type ? function(e, t) {
                            var i = function() {
                                    me(e, t), r()
                                },
                                s = function() {
                                    r()
                                },
                                r = function() {
                                    removeEventListener("pointerup", i, pe), removeEventListener("pointercancel", s, pe)
                                };
                            addEventListener("pointerup", i, pe), addEventListener("pointercancel", s, pe)
                        }(t, e) : me(t, e)
                    }
                },
                ye = function(e) {
                    ["mousedown", "keydown", "touchstart", "pointerdown"].forEach((function(t) {
                        return e(t, ve, pe)
                    }))
                },
                be = [100, 300],
                Te = function(e, t) {
                    ! function(e, t) {
                        t = t || {}, R((function() {
                            var i, s = I(),
                                r = p("FID"),
                                n = function(e) {
                                    e.startTime < s.firstHiddenTime && (r.value = e.processingStart - e.startTime, r.entries.push(e), i(!0))
                                },
                                a = function(e) {
                                    e.forEach(n)
                                },
                                o = f("first-input", a);
                            i = m(e, r, be, t.reportAllChanges), o && (v(y((function() {
                                a(o.takeRecords()), o.disconnect()
                            }))), d((function() {
                                var s;
                                r = p("FID"), i = m(e, r, be, t.reportAllChanges), se = [], $ = -1, te = null, ye(addEventListener), s = n, se.push(s), ge()
                            })))
                        }))
                    }((function(t) {
                        var i = function(e) {
                            var t = e.entries[0],
                                i = {
                                    eventTarget: c(t.target),
                                    eventType: t.name,
                                    eventTime: t.startTime,
                                    eventEntry: t,
                                    loadState: a(t.startTime)
                                };
                            return Object.assign(e, {
                                attribution: i
                            })
                        }(t);
                        e(i)
                    }), t)
                }
        }
    }
]);